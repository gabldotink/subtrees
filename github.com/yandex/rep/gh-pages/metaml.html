

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Meta Machine Learning &mdash; REP (Reproducible Experiment Platform) 0.6.7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="REP (Reproducible Experiment Platform) 0.6.7 documentation" href="index.html"/>
        <link rel="next" title="Report for models" href="report.html"/>
        <link rel="prev" title="Estimators (classification and regression)" href="estimators.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> REP (Reproducible Experiment Platform)
          

          
          </a>

          
            
            
              <div class="version">
                0.6.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="estimators.html">Estimators (classification and regression)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Meta Machine Learning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.factory">Factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#factory-examples">Factory Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.gridsearch">Grid Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gridoptimalsearchcv">GridOptimalSearchCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="#folding-scorer">Folding Scorer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#available-optimization-algorithms">Available optimization algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interface-of-parameter-optimizer">Interface of parameter optimizer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.folding">Folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.cache">Cache</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-of-usage">Example of usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.stacking">Stacking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="report.html">Report for models</a></li>
<li class="toctree-l1"><a class="reference internal" href="metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="reproducibility.html">REProducibility</a></li>
<li class="toctree-l1"><a class="reference external" href="http://nbviewer.ipython.org/github/yandex/rep/tree/master/howto/">Howto notebooks</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">REP (Reproducible Experiment Platform)</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Meta Machine Learning</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/metaml.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="meta-machine-learning">
<span id="metaml"></span><h1>Meta Machine Learning<a class="headerlink" href="#meta-machine-learning" title="Permalink to this headline">¶</a></h1>
<p>Meta machine learning contains specific ML-algorithms, that are taking some classification/regression model as an input.</p>
<p>Also there is a Factory which allows set of models training and comparing them very simply.</p>
<div class="section" id="module-rep.metaml.factory">
<span id="factory"></span><h2>Factory<a class="headerlink" href="#module-rep.metaml.factory" title="Permalink to this headline">¶</a></h2>
<p><strong>Factory</strong> provides convenient way to train several classifiers on the same dataset.
These classifiers can be trained one-by-one in a single thread, or simultaneously
with IPython cluster or in several threads.</p>
<p>Also <code class="xref py py-class docutils literal"><span class="pre">Factory</span></code> allows comparison of several classifiers (predictions of which can be computed again in parallel).</p>
<dl class="class">
<dt id="rep.metaml.factory.ClassifiersFactory">
<em class="property">class </em><code class="descclassname">rep.metaml.factory.</code><code class="descname">ClassifiersFactory</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.factory.AbstractFactory</span></code></p>
<p>Factory provides training of several classifiers in parallel.
Quality of trained classifiers can be compared.</p>
<p>Initialize an ordered dictionary.  The signature is the same as
regular dictionaries, but keyword arguments are not recommended because
their insertion order is arbitrary.</p>
<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.add_classifier">
<code class="descname">add_classifier</code><span class="sig-paren">(</span><em>name</em>, <em>classifier</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.add_classifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.add_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Add classifier to factory.
Automatically wraps classifier with <code class="xref py py-class docutils literal"><span class="pre">SklearnClassifier</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; unique name for classifier.
If name coincides with one already used, the old classifier will be replaced by one passed.</li>
<li><strong>classifier</strong> (<em>sklearn.base.BaseEstimator or estimators.interface.Classifier</em>) &#8211; <p>classifier object</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if type == sklearn.base.BaseEstimator, then features=None is used,
to specify features used by classifier, wrap it with <code class="xref py py-class docutils literal"><span class="pre">SklearnClassifier</span></code></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile for IPython cluster</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with integer labels]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with float predictions]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.staged_predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities on each stage (attention: returns dictionary of generators)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict[iterator]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.test_on_lds">
<code class="descname">test_on_lds</code><span class="sig-paren">(</span><em>lds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.test_on_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.test_on_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare report for factory of estimators</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="report.html#rep.report.classification.ClassificationReport" title="rep.report.classification.ClassificationReport">rep.report.classification.ClassificationReport</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.factory.RegressorsFactory">
<em class="property">class </em><code class="descclassname">rep.metaml.factory.</code><code class="descname">RegressorsFactory</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.factory.AbstractFactory</span></code></p>
<p>Factory provides training of several classifiers in parallel.
Quality of trained regressors can be compared.</p>
<p>Initialize an ordered dictionary.  The signature is the same as
regular dictionaries, but keyword arguments are not recommended because
their insertion order is arbitrary.</p>
<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.add_regressor">
<code class="descname">add_regressor</code><span class="sig-paren">(</span><em>name</em>, <em>regressor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.add_regressor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.add_regressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add regressor to factory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; unique name for regressor.
If name coincides with one already used, the old regressor will be replaced by one passed.</li>
<li><strong>regressor</strong> (<em>sklearn.base.BaseEstimator or estimators.interface.Regressor</em>) &#8211; <p>regressor object</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if type == sklearn.base.BaseEstimator, then features=None is used,
to specify features used by regressor, wrap it first with <code class="xref py py-class docutils literal"><span class="pre">SklearnRegressor</span></code></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict values for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or name of profile to parallelize computations.</em>) &#8211; profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with float values]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.staged_predict">
<code class="descname">staged_predict</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.staged_predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.staged_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicts probabilities on each stage</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict[iterator]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.test_on_lds">
<code class="descname">test_on_lds</code><span class="sig-paren">(</span><em>lds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.test_on_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.test_on_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Report for factory of estimators</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="report.html#rep.report.regression.RegressionReport" title="rep.report.regression.RegressionReport">rep.report.regression.RegressionReport</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="factory-examples">
<h2>Factory Examples<a class="headerlink" href="#factory-examples" title="Permalink to this headline">¶</a></h2>
<ul>
<li><dl class="first docutils">
<dt>Prepare dataset</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span><span class="o">,</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.utils</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iris data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Take just two classes instead of three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_data</span><span class="p">,</span> <span class="n">test_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Train factory of classifiers</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="kn">import</span> <span class="n">ClassifiersFactory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.estimators</span> <span class="kn">import</span> <span class="n">TMVAClassifier</span><span class="p">,</span> <span class="n">SklearnClassifier</span><span class="p">,</span> <span class="n">XGBoostClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span> <span class="o">=</span> <span class="n">ClassifiersFactory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">add_classifier</span><span class="p">(</span><span class="s1">&#39;tmva&#39;</span><span class="p">,</span> <span class="n">TMVAClassifier</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;kBDT&#39;</span><span class="p">,</span> <span class="n">NTrees</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">Shrinkage</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">nCuts</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">BoostType</span><span class="o">=</span><span class="s1">&#39;Grad&#39;</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">add_classifier</span><span class="p">(</span><span class="s1">&#39;ada&#39;</span><span class="p">,</span> <span class="n">GradientBoostingClassifier</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="p">[</span><span class="s1">&#39;xgb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XGBoostClassifier</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="go">model ef           was trained in 0.22 seconds</span>
<span class="go">model tmva         was trained in 2.47 seconds</span>
<span class="go">model ada          was trained in 0.02 seconds</span>
<span class="go">model xgb          was trained in 0.01 seconds</span>
<span class="go">Totally spent 2.71 seconds on training</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
<span class="go">data was predicted by tmva         in 0.02 seconds</span>
<span class="go">data was predicted by ada          in 0.00 seconds</span>
<span class="go">data was predicted by xgb          in 0.00 seconds</span>
<span class="go">Totally spent 0.05 seconds on prediction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pred</span>
<span class="go">OrderedDict([(&#39;tmva&#39;, array([[  9.98732217e-01,   1.26778255e-03], [  9.99649503e-01,   3.50497149e-04], ..])),</span>
<span class="go">             (&#39;ada&#39;, array([[  9.99705117e-01,   2.94883265e-04], [  9.99705117e-01,   2.94883265e-04], ..])),</span>
<span class="go">             (&#39;xgb&#39;, array([[  9.91589248e-01,   8.41078255e-03], ..], dtype=float32))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pred</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">test_labels</span><span class="p">,</span> <span class="n">pred</span><span class="p">[</span><span class="n">key</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">tmva 0.933035714286</span>
<span class="go">ada 1.0</span>
<span class="go">xgb 0.995535714286</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="module-rep.metaml.gridsearch">
<span id="grid-search"></span><h2>Grid Search<a class="headerlink" href="#module-rep.metaml.gridsearch" title="Permalink to this headline">¶</a></h2>
<p>This module does hyper parameters optimization &#8211; finds the best parameters for estimator using different optimization models.
Components of optimization:</p>
<ul class="simple">
<li>estimator (for which optimal parameters are searched, any REP classifier will work, see <code class="xref py py-mod docutils literal"><span class="pre">rep.estimators</span></code>)</li>
<li>target metric function (which is maximized, anything meeting REP metric interface, see <a class="reference internal" href="metrics.html#module-rep.report.metrics" title="rep.report.metrics"><code class="xref py py-mod docutils literal"><span class="pre">rep.report.metrics</span></code></a>)</li>
<li>optimization algorithm (introduced in this module)</li>
<li>cross-validation technique (kFolding, introduced in this module)</li>
</ul>
<p>During optimization, many cycles of estimating quality on different sets of parameters is done.
To speed up the process, threads or IPython cluster can be used.</p>
<div class="section" id="gridoptimalsearchcv">
<h3>GridOptimalSearchCV<a class="headerlink" href="#gridoptimalsearchcv" title="Permalink to this headline">¶</a></h3>
<p>Main class linking the whole process is <a class="reference internal" href="#rep.metaml.gridsearch.GridOptimalSearchCV" title="rep.metaml.gridsearch.GridOptimalSearchCV"><code class="xref py py-class docutils literal"><span class="pre">GridOptimalSearchCV</span></code></a>, which takes as parameters:</p>
<ul class="simple">
<li>estimator to be optimized</li>
<li>scorer (which trains classifier and estimates quality using cross-validation)</li>
<li>parameter generator (which draws next set of parameters to be checked)</li>
</ul>
<dl class="class">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">GridOptimalSearchCV</code><span class="sig-paren">(</span><em>estimator</em>, <em>params_generator</em>, <em>scorer</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Optimal search over specified parameter values for an estimator.
Uses different optimization techniques to use limited number of evaluations without using exhaustive grid scanning.</p>
<p>GridSearchCV implements a &#8220;fit&#8221; method and a &#8220;fit_best_estimator&#8221; method to train models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>estimator</strong> (<em>BaseEstimator</em>) &#8211; object of type that implements the &#8220;fit&#8221; and &#8220;fit_best_estimator&#8221; methods
A new object of that type is cloned for each point.</li>
<li><strong>params_generator</strong> (<a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><em>AbstractParameterGenerator</em></a>) &#8211; generator of grid search algorithm</li>
<li><strong>scorer</strong> (<em>object</em>) &#8211; which implement method __call__ with kwargs:
&#8220;base_estimator&#8221;, &#8220;params&#8221;, &#8220;X&#8221;, &#8220;y&#8221;, &#8220;sample_weight&#8221;</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; name of profile</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Attributes</strong>:</p>
<p>generator: return grid parameter generator</p>
<dl class="method">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run fit with all sets of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; array-like, shape = [n_samples, n_features]
Training vector, where n_samples is the number of samples and n_features is the number of features.</li>
<li><strong>y</strong> &#8211; array-like, shape = [n_samples] or [n_samples, n_output], optional</li>
<li><strong>sample_weight</strong> &#8211; array-like, shape = [n_samples], weight</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.fit_best_estimator">
<code class="descname">fit_best_estimator</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV.fit_best_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.fit_best_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Train estimator with the best parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the best estimator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.generator">
<code class="descname">generator</code><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Property for params_generator</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="folding-scorer">
<h3>Folding Scorer<a class="headerlink" href="#folding-scorer" title="Permalink to this headline">¶</a></h3>
<p>Folding cross validation can be used in grid search optimization.</p>
<dl class="class">
<dt id="rep.metaml.gridsearch.ClassificationFoldingScorer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">ClassificationFoldingScorer</code><span class="sig-paren">(</span><em>score_function</em>, <em>folds=3</em>, <em>fold_checks=1</em>, <em>shuffle=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#ClassificationFoldingScorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.ClassificationFoldingScorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.FoldingScorerBase</span></code></p>
<p>Scorer, which implements logic of data folding and scoring for classification models. This is a function-like object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>folds</strong> (<em>int</em>) &#8211; &#8216;k&#8217; used in k-folding while validating</li>
<li><strong>fold_checks</strong> (<em>int</em>) &#8211; not greater than folds, the number of checks we do by cross-validating</li>
<li><strong>score_function</strong> (<em>function</em>) &#8211; quality. if fold_checks &gt; 1, the average is computed over checks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">new_score_function</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">proba</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    y_true: [n_samples]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    proba: [n_samples, n_classes]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    sample_weight: [n_samples] or None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="o">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_scorer</span> <span class="o">=</span> <span class="n">FoldingScorer</span><span class="p">(</span><span class="n">new_score_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_scorer</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>Scorer, which implements logic of data folding and scoring. This is a function-like object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>folds</strong> (<em>int</em>) &#8211; &#8216;k&#8217; used in k-folding while validating</li>
<li><strong>fold_checks</strong> (<em>int</em>) &#8211; not greater than folds, the number of checks we do by cross-validating</li>
<li><strong>score_function</strong> (<em>function</em>) &#8211; quality. if fold_checks &gt; 1, the average is computed over checks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.RegressionFoldingScorer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">RegressionFoldingScorer</code><span class="sig-paren">(</span><em>score_function</em>, <em>folds=3</em>, <em>fold_checks=1</em>, <em>shuffle=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RegressionFoldingScorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RegressionFoldingScorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.FoldingScorerBase</span></code></p>
<p>Scorer, which implements logic of data folding and scoring for regression models. This is a function-like object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>folds</strong> (<em>int</em>) &#8211; &#8216;k&#8217; used in k-folding while validating</li>
<li><strong>fold_checks</strong> (<em>int</em>) &#8211; not greater than folds, the number of checks we do by cross-validating</li>
<li><strong>score_function</strong> (<em>function</em>) &#8211; quality. if fold_checks &gt; 1, the average is computed over checks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">new_score_function</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    y_true: [n_samples]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    pred: [n_samples]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    sample_weight: [n_samples] or None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="o">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_scorer</span> <span class="o">=</span> <span class="n">RegressionFoldingScorer</span><span class="p">(</span><span class="n">new_score_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_scorer</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>Scorer, which implements logic of data folding and scoring. This is a function-like object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>folds</strong> (<em>int</em>) &#8211; &#8216;k&#8217; used in k-folding while validating</li>
<li><strong>fold_checks</strong> (<em>int</em>) &#8211; not greater than folds, the number of checks we do by cross-validating</li>
<li><strong>score_function</strong> (<em>function</em>) &#8211; quality. if fold_checks &gt; 1, the average is computed over checks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="available-optimization-algorithms">
<h3>Available optimization algorithms<a class="headerlink" href="#available-optimization-algorithms" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">RandomParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>maximize=True</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RandomParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>Works in the same way as sklearn.grid_search.RandomizedSearch.
Each next point is generated independently.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param_grid:</th><td class="field-body">dict with distributions used to sample each parameter.
name -&gt; list of possible values (in which case sampled uniformly from options)
name -&gt; distribution (should implement &#8216;.rvs()&#8217; as scipy distributions)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maximize</strong> (<em>bool</em>) &#8211; ignored parameter, added for uniformity</td>
</tr>
</tbody>
</table>
<p>NB: this is the only optimizer, which supports passing distributions for parameters.</p>
<dl class="method">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RandomParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">AnnealingParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>temperature=0.2</em>, <em>random_state=None</em>, <em>maximize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>Implementation if annealing algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number od evaluations</li>
<li><strong>temperature</strong> &#8211; float, how tolerant we are to worse results.
If temperature is very small, algorithm never steps to point with worse predictions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Doesn&#8217;t support parallel execution, so cannot be used in optimization on cluster.</p>
<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer.generate_batch_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">SubgridParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em>, <em>start_evaluations=3</em>, <em>subgrid_size=3</em>, <em>maximize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>Uses Metropolis-like optimization.
If the parameter grid is large, first performs optimization on subgrid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
<li><strong>start_evaluations</strong> (<em>int</em>) &#8211; count of random point generation on start</li>
<li><strong>subgrid_size</strong> (<em>int</em>) &#8211; if the size of mesh too large, first we will optimize
on subgrid with not more then subgrid_size possible values for each parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.add_result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next point in parameters space</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">RegressionParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em>, <em>start_evaluations=3</em>, <em>n_attempts=10</em>, <em>regressor=None</em>, <em>maximize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RegressionParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>This general method relies on regression.
Regressor will try to predict the best point based on already known result fir different parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
<li><strong>start_evaluations</strong> (<em>int</em>) &#8211; count of random point generation on start</li>
<li><strong>n_attempts</strong> (<em>int</em>) &#8211; this number of points will be compared on each iteration.
Regressor is to choose optimal from them.</li>
<li><strong>regressor</strong> &#8211; regressor to choose appropriate next point with potential best score
(estimated this score by regressor); If None them RandomForest algorithm will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RegressionParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interface-of-parameter-optimizer">
<h3>Interface of parameter optimizer<a class="headerlink" href="#interface-of-parameter-optimizer" title="Permalink to this headline">¶</a></h3>
<p>Each of parameter optimizers has the following interface.</p>
<dl class="class">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">AbstractParameterGenerator</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>maximize=True</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract class for grid search algorithm.
The aim of this class is to generate new points, where the function (estimator) will be computed.
You can define your own algorithm of step location of parameters grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
<li><strong>maximize</strong> &#8211; whether algorithm should maximize or minimize target function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>After the model was trained and evaluated for specific set of parameters,
we use this function to store result
:param state_indices: tuple, which represents the space
:param value: quality at this point</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.generate_batch_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate several points in parameter space at once (needed when using parallel computations)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; how many points we shall generate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple of arrays (state_indices, state_parameters)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space
:return: tuple (indices, parameters)</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.print_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-rep.metaml.folding">
<span id="folding"></span><h2>Folding<a class="headerlink" href="#module-rep.metaml.folding" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#rep.metaml.folding.FoldingClassifier" title="rep.metaml.folding.FoldingClassifier"><code class="xref py py-class docutils literal"><span class="pre">FoldingClassifier</span></code></a> and <a class="reference internal" href="#rep.metaml.folding.FoldingRegressor" title="rep.metaml.folding.FoldingRegressor"><code class="xref py py-class docutils literal"><span class="pre">FoldingRegressor</span></code></a> provide an easy way
to run k-Folding cross-validation. Also it is a nice way to combine predictions of trained classifiers.</p>
<dl class="class">
<dt id="rep.metaml.folding.FoldingClassifier">
<em class="property">class </em><code class="descclassname">rep.metaml.folding.</code><code class="descname">FoldingClassifier</code><span class="sig-paren">(</span><em>base_estimator</em>, <em>n_folds=2</em>, <em>random_state=None</em>, <em>features=None</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.folding.FoldingBase</span></code>, <a class="reference internal" href="estimators.html#rep.estimators.interface.Classifier" title="rep.estimators.interface.Classifier"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.interface.Classifier</span></code></a></p>
<p>This meta-classifier implements folding algorithm:</p>
<ul class="simple">
<li>split training data into n equal parts;</li>
<li>train n classifiers, each one is trained using n-1 folds</li>
</ul>
<p>To get unbiased predictions for data, pass the <strong>same</strong> dataset (with same order of events)
as in training to prediction methods,
in which case each event is predicted with base classifier which didn&#8217;t use that event during training.</p>
<p>To use information from not one, but several estimators during predictions,
provide appropriate voting function. Examples of voting function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">voting</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voting</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>base_estimator</strong> (<em>sklearn.BaseEstimator</em>) &#8211; base classifier, which will be used for training</li>
<li><strong>n_folds</strong> (<em>int</em>) &#8211; count of folds</li>
<li><strong>features</strong> (<em>None or list[str]</em>) &#8211; features used in training</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile for IPython cluster, None to compute locally.</li>
<li><strong>random_state</strong> (<em>None or int or RandomState</em>) &#8211; random state for reproducibility</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="rep.metaml.folding.FoldingClassifier.feature_importances_">
<code class="descname">feature_importances_</code><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.feature_importances_" title="Permalink to this definition">¶</a></dt>
<dd><p>Sklearn-way of returning feature importance.
This returned as numpy.array, assuming that initially passed train_features=None</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the model, will train several base classifiers on overlapping
subsets of training dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.get_feature_importances">
<code class="descname">get_feature_importances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.get_feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get features importance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">pandas.DataFrame with column effect and <cite>index=features</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels. To get unbiased predictions on training dataset, pass training data
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array of shape [n_samples]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities. To get unbiased predictions on training dataset, pass training data
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array of shape [n_samples, n_classes]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities after each stage of base_estimator.
To get unbiased predictions on training dataset, pass training data
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sequence of numpy.arrays of shape [n_samples, n_classes]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.folding.FoldingRegressor">
<em class="property">class </em><code class="descclassname">rep.metaml.folding.</code><code class="descname">FoldingRegressor</code><span class="sig-paren">(</span><em>base_estimator</em>, <em>n_folds=2</em>, <em>random_state=None</em>, <em>features=None</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingRegressor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.folding.FoldingBase</span></code>, <a class="reference internal" href="estimators.html#rep.estimators.interface.Regressor" title="rep.estimators.interface.Regressor"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.interface.Regressor</span></code></a></p>
<p>This meta-regressor implements folding algorithm:</p>
<ul class="simple">
<li>split training data into n equal parts;</li>
<li>train n regressors, each one is trained using n-1 folds</li>
</ul>
<p>To get unbiased predictions for data, pass the <strong>same</strong> dataset (with same order of events)
as in training to prediction methods,
in which case each event is predicted with base regressor which didn&#8217;t use that event during training.</p>
<p>To use information from not one, but several estimators during predictions,
provide appropriate voting function. Examples of voting function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">voting</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voting</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>base_estimator</strong> (<em>sklearn.BaseEstimator</em>) &#8211; base classifier, which will be used for training</li>
<li><strong>n_folds</strong> (<em>int</em>) &#8211; count of folds</li>
<li><strong>features</strong> (<em>None or list[str]</em>) &#8211; features used in training</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile for IPython cluster, None to compute locally.</li>
<li><strong>random_state</strong> (<em>None or int or RandomState</em>) &#8211; random state for reproducibility</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="rep.metaml.folding.FoldingRegressor.feature_importances_">
<code class="descname">feature_importances_</code><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor.feature_importances_" title="Permalink to this definition">¶</a></dt>
<dd><p>Sklearn-way of returning feature importance.
This returned as numpy.array, assuming that initially passed train_features=None</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingRegressor.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the model, will train several base regressors on overlapping
subsets of training dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingRegressor.get_feature_importances">
<code class="descname">get_feature_importances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor.get_feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get features importance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">pandas.DataFrame with column effect and <cite>index=features</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingRegressor.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predictions. To get unbiased predictions on training dataset, pass training data
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used. Parameters: numpy.ndarray [n_classifiers, n_samples]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array of shape [n_samples, n_outputs]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingRegressor.staged_predict">
<code class="descname">staged_predict</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.folding.FoldingRegressor.staged_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predictions after each iteration of base estimator.
To get unbiased predictions on training dataset, pass training data
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used. Parameters: numpy.ndarray [n_classifiers, n_samples]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">sequence of numpy.array of shape [n_samples, n_outputs]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rep.metaml.cache">
<span id="cache"></span><h2>Cache<a class="headerlink" href="#module-rep.metaml.cache" title="Permalink to this headline">¶</a></h2>
<p>In many cases training a classification/regression takes hours.
To avoid retraining at each step, one can store trained classifier in a file,
and later load trained model.</p>
<p>However, in this case user should care about situations when something changed in the pipeline
(for instance, train/test splitting) manually.</p>
<p>Cache estimators are lazy way to store trained model.
After training, classifier/regressor is stored in the file under specific name (which was passed in constructor).</p>
<p>On the next runs following conditions are checked:</p>
<ul class="simple">
<li>model has the same name</li>
<li>model trained has exactly same parameters</li>
<li>model is trained using exactly the same data</li>
<li>stored copy in not too old (10 days by default)</li>
</ul>
<p>If all the conditions satisfied, stored copy is loaded, otherwise classifier/regressor is fitted.</p>
<div class="section" id="example-of-usage">
<h3>Example of usage<a class="headerlink" href="#example-of-usage" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#rep.metaml.cache.CacheClassifier" title="rep.metaml.cache.CacheClassifier"><code class="xref py py-class docutils literal"><span class="pre">CacheClassifier</span></code></a> and <a class="reference internal" href="#rep.metaml.cache.CacheRegressor" title="rep.metaml.cache.CacheRegressor"><code class="xref py py-class docutils literal"><span class="pre">CacheRegressor</span></code></a> work as meta-estimators</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.estimators</span> <span class="kn">import</span> <span class="n">XGBoostClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="kn">import</span> <span class="n">FoldingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.metaml.cache</span> <span class="kn">import</span> <span class="n">CacheClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">CacheClassifier</span><span class="p">(</span><span class="s1">&#39;xgboost folding&#39;</span><span class="p">,</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">XGBoostClassifier</span><span class="p">(),</span> <span class="n">n_folds</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this works normally</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">testX</span><span class="p">)</span>
</pre></div>
</div>
<p>However in the following situation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">FoldingClassifier</span><span class="p">(</span><span class="n">CacheClassifier</span><span class="p">(</span><span class="s1">&#39;xgboost&#39;</span><span class="p">,</span> <span class="n">XGBoostClassifier</span><span class="p">()))</span>
</pre></div>
</div>
<p>cache is not going to work, because for each fold a copy of classifier is created.
Each time after looking at cache, a version with same parameters, but different data will be found.</p>
<p>So, every time stored copy will be erased and a new one saved.</p>
<p>By default, cache is stored in &#8216;.cache/rep&#8217; subfolder of project directory (where the ipython notebook is placed).
To change parameters of caching use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">rep.metaml.cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.metaml._cache</span> <span class="kn">import</span> <span class="n">CacheHelper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep</span><span class="o">.</span><span class="n">metaml</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">cache_helper</span> <span class="o">=</span> <span class="n">CacheHelper</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">expiration_in_seconds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to delete all cached items, use:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep</span><span class="o">.</span><span class="n">metaml</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">cache_helper</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="rep.metaml.cache.CacheClassifier">
<em class="property">class </em><code class="descclassname">rep.metaml.cache.</code><code class="descname">CacheClassifier</code><span class="sig-paren">(</span><em>name</em>, <em>clf</em>, <em>features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/cache.html#CacheClassifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.cache.CacheClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.cache.CacheBase</span></code>, <a class="reference internal" href="estimators.html#rep.estimators.sklearn.SklearnClassifier" title="rep.estimators.sklearn.SklearnClassifier"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.sklearn.SklearnClassifier</span></code></a></p>
<p>Cache classifier allows to save trained models in lazy way.
Useful when training classifier takes much time.</p>
<p>On the next run, stored model in cache will be used instead of fitting again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; unique name of classifier (to be used in storing)</li>
<li><strong>clf</strong> (<em>sklearn.BaseEstimator</em>) &#8211; your estimator, which will be used for training</li>
<li><strong>features</strong> &#8211; features to use in training.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="rep.metaml.cache.CacheRegressor">
<em class="property">class </em><code class="descclassname">rep.metaml.cache.</code><code class="descname">CacheRegressor</code><span class="sig-paren">(</span><em>name</em>, <em>clf</em>, <em>features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/cache.html#CacheRegressor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.cache.CacheRegressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">rep.metaml.cache.CacheBase</span></code>, <a class="reference internal" href="estimators.html#rep.estimators.sklearn.SklearnRegressor" title="rep.estimators.sklearn.SklearnRegressor"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.sklearn.SklearnRegressor</span></code></a></p>
<p>Cache regressor allows to save trained models in lazy way.
Useful when training regressor takes much time.</p>
<p>On the next run, stored model in cache will be used instead of fitting again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; unique name of classifier (to be used in storing)</li>
<li><strong>clf</strong> (<em>sklearn.BaseEstimator</em>) &#8211; your estimator, which will be used for training</li>
<li><strong>features</strong> &#8211; features to use in training.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-rep.metaml.stacking">
<span id="stacking"></span><h2>Stacking<a class="headerlink" href="#module-rep.metaml.stacking" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#rep.metaml.stacking.FeatureSplitter" title="rep.metaml.stacking.FeatureSplitter"><code class="xref py py-class docutils literal"><span class="pre">FeatureSplitter</span></code></a>  defined in this module.</p>
<p>This meta-algorithm is handy to train different models for subsets of the data
without manually splitting the data into parts.</p>
<dl class="class">
<dt id="rep.metaml.stacking.FeatureSplitter">
<em class="property">class </em><code class="descclassname">rep.metaml.stacking.</code><code class="descname">FeatureSplitter</code><span class="sig-paren">(</span><em>split_feature</em>, <em>base_estimator</em>, <em>train_features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="estimators.html#rep.estimators.interface.Classifier" title="rep.estimators.interface.Classifier"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.interface.Classifier</span></code></a></p>
<p>Dataset is split by values of <cite>split_feature</cite>,
for each value of feature, new classifier is trained.</p>
<p>When building predictions, classifier predicts the events with
the same value of <cite>split_feature</cite> it was trained on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>split_feature</strong> (<em>str</em>) &#8211; the name of key feature</li>
<li><strong>base_estimator</strong> &#8211; the classifier, its&#8217; copies are trained on parts of dataset</li>
<li><strong>train_features</strong> (<em>list[str]</em>) &#8211; list of columns classifier uses in training</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features] with features</li>
<li><strong>y</strong> &#8211; array-like of shape [n_samples] with targets</li>
<li><strong>sample_weight</strong> &#8211; array-like of shape [n_samples] with events weights or None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities.
Each event is predicted by the classifier trained on corresponding value of <cite>split_feature</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">probabilities of shape [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.staged_predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities after each stage of base classifier.
Each event is predicted by the classifier trained on corresponding value of <cite>split_feature</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">iterable sequence of numpy.arrays of shape [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="report.html" class="btn btn-neutral float-right" title="Report for models" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="estimators.html" class="btn btn-neutral" title="Estimators (classification and regression)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2015, Yandex.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.6.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>