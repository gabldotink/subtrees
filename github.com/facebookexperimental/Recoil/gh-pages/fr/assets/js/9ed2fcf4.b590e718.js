"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[6776],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),u=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=u(n),c=a,f=m["".concat(s,".").concat(c)]||m[c]||p[c]||r;return n?o.createElement(f,i(i({ref:t},d),{},{components:n})):o.createElement(f,i({ref:t},d))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2033:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return d},default:function(){return m}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],l={title:"Bonus: Performance"},s=void 0,u={unversionedId:"basic-tutorial/performance",id:"basic-tutorial/performance",title:"Bonus: Performance",description:"Notre impl\xe9mentation existante est parfaitement valide, mais il y a des implications importantes sur les performances \xe0 prendre en compte \xe0 mesure que notre application \xe9volue d'un petit projet \xe0 un programme d'entreprise d'un million de lignes.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/basic-tutorial/performance.md",sourceDirName:"basic-tutorial",slug:"/basic-tutorial/performance",permalink:"/fr/docs/basic-tutorial/performance",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/i18n/fr/docusaurus-plugin-content-docs/current/basic-tutorial/performance.md",tags:[],version:"current",frontMatter:{title:"Bonus: Performance"}},d=[{value:"<code>&lt;TodoList /&gt;</code>",id:"todolist-",children:[],level:3},{value:"<code>&lt;TodoItem /&gt;</code>",id:"todoitem-",children:[],level:3},{value:"<code>&lt;TodoItemCreator /&gt;</code>",id:"todoitemcreator-",children:[],level:3},{value:"<code>&lt;TodoListFilters /&gt;</code>",id:"todolistfilters-",children:[],level:3},{value:"<code>&lt;TodoListStats /&gt;</code>",id:"todoliststats-",children:[],level:3},{value:"Marge d&#39;am\xe9lioration",id:"marge-dam\xe9lioration",children:[],level:2},{value:"Optimisation # 1: <code>React.memo ()</code>",id:"optimisation--1-reactmemo-",children:[],level:2},{value:"Optimisation # 2: <code>atomFamily()</code>",id:"optimisation--2-atomfamily",children:[{value:"Repenser la forme de l&#39;\xe9tat",id:"repenser-la-forme-de-l\xe9tat",children:[],level:3},{value:"<code>atomFamily ()</code>",id:"atomfamily-",children:[],level:3}],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Notre impl\xe9mentation existante est parfaitement valide, mais il y a des implications importantes sur les performances \xe0 prendre en compte \xe0 mesure que notre application \xe9volue d'un petit projet \xe0 un programme d'entreprise d'un million de lignes."),(0,r.kt)("p",null,"Pensons \xe0 ce qui provoquera le nouveau rendu de chacun de nos composants:"),(0,r.kt)("h3",{id:"todolist-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<TodoList />")),(0,r.kt)("p",null,"Ce composant est abonn\xe9 \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"filteredTodoListState"),", qui est un s\xe9lecteur qui a une d\xe9pendance sur",(0,r.kt)("inlineCode",{parentName:"p"}," todoListState")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListFilterState"),". Cela signifie que ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoList")," sera de nouveau rendu lorsque l'\xe9tat suivant change:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"todoListState")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"todoListFilterState"))),(0,r.kt)("h3",{id:"todoitem-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<TodoItem />")),(0,r.kt)("p",null,"Ce composant est abonn\xe9 \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListState"),", il sera donc \xe0 nouveau rendu chaque fois que ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListState")," change et chaque fois que son composant parent, ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoList"),", est \xe0 nouveau rendu."),(0,r.kt)("h3",{id:"todoitemcreator-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<TodoItemCreator />")),(0,r.kt)("p",null,"Ce composant n'est pas abonn\xe9 \xe0 l'\xe9tat Recoil (",(0,r.kt)("inlineCode",{parentName:"p"},"useSetRecoilState()")," ne cr\xe9e pas d'abonnement), il ne sera donc de nouveau rendu que lorsque son composant parent, ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoList"),", sera de nouveau rendu."),(0,r.kt)("h3",{id:"todolistfilters-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<TodoListFilters />")),(0,r.kt)("p",null,"Ce composant est souscrit \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListFilterState"),", il sera donc \xe0 nouveau rendu lorsque cet \xe9tat change ou lorsque son composant parent,",(0,r.kt)("inlineCode",{parentName:"p"},"TodoList"),", est \xe0 nouveau rendu."),(0,r.kt)("h3",{id:"todoliststats-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<TodoListStats />")),(0,r.kt)("p",null,"Ce composant est abonn\xe9 \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"filteredTodoListState"),", il sera donc \xe0 nouveau rendu chaque fois que cet \xe9tat change ou lorsque son composant parent,",(0,r.kt)("inlineCode",{parentName:"p"},"TodoList"),", est \xe0 nouveau rendu."),(0,r.kt)("h2",{id:"marge-dam\xe9lioration"},"Marge d'am\xe9lioration"),(0,r.kt)("p",null,"L'impl\xe9mentation existante a quelques inconv\xe9nients, principalement le fait que nous sommes en train de refaire le rendu de l'arbre entier chaque fois que nous apportons une modification \xe0 ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListState")," en raison du fait que ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoList />")," est le parent de tous nos composants, donc quand il re-rendra, tous ses enfants le seront aussi."),(0,r.kt)("p",null,"Dans l'id\xe9al, les composants ne seraient re-rendu que lorsqu'ils doivent absolument le faire (lorsque les donn\xe9es qu'ils affichent \xe0 l'\xe9cran auront chang\xe9es)."),(0,r.kt)("h2",{id:"optimisation--1-reactmemo-"},"Optimisation # 1: ",(0,r.kt)("inlineCode",{parentName:"h2"},"React.memo ()")),(0,r.kt)("p",null,"Pour att\xe9nuer le probl\xe8me du r\xe9-rendu des composants enfants inutilement, nous pouvons utiliser ","[",(0,r.kt)("inlineCode",{parentName:"p"},"React.memo()"),"]"," (",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/react-api.html#reactmemo"},"https://reactjs.org/docs/react-api.html#reactmemo"),"), qui m\xe9morise un composant bas\xe9 sur les ",(0,r.kt)("strong",{parentName:"p"},"props")," pass\xe9s \xe0 ce composant:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const TodoItem = React.memo(({item}) => ...);\n\nconst TodoItemCreator = React.memo(() => ...);\n\nconst TodoListFilters = React.memo(() => ...);\n\nconst TodoListStats = React.memo(() => ...);\n")),(0,r.kt)("p",null,"Cela aide avec les r\xe9-rendus de ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoItemCreator />")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoListFilters />")," car ils ne sont plus re-rendu en r\xe9ponse aux re-rendu de leur composant parent, ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoList />"),", mais nous avons toujours le probl\xe8me du re-rendu de ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoItem />")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoListStats />")," lorsque des t\xe2ches individuelles voient leur texte chang\xe9 car les modifications de texte entra\xeeneront un nouveau ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListFilterState"),", qui \xe0 la fois ",(0,r.kt)("inlineCode",{parentName:"p"},"<TodoItem />")," et ",(0,r.kt)("inlineCode",{parentName:"p"},"< TodoListStats />"),"sont abonn\xe9s."),(0,r.kt)("h2",{id:"optimisation--2-atomfamily"},"Optimisation # 2: ",(0,r.kt)("inlineCode",{parentName:"h2"},"atomFamily()")),(0,r.kt)("h3",{id:"repenser-la-forme-de-l\xe9tat"},"Repenser la forme de l'\xe9tat"),(0,r.kt)("p",null,"Voir une liste de t\xe2ches comme un tableau d'objets est probl\xe9matique car elle forme un couplage \xe9troit entre chaque \xe9l\xe9ment de t\xe2che individuelle et la liste de toutes les t\xe2ches."),(0,r.kt)("p",null,"Pour r\xe9soudre ce probl\xe8me, nous devons repenser la forme de notre \xe9tat en pensant \xe0 ",(0,r.kt)("strong",{parentName:"p"},"l'\xe9tat normalis\xe9"),". Dans le contexte de notre application, cela signifie stocker la ",(0,r.kt)("strong",{parentName:"p"},"liste")," des identifiants d'\xe9l\xe9ment s\xe9par\xe9ment des ",(0,r.kt)("strong",{parentName:"p"},"donn\xe9es")," pour chaque \xe9l\xe9ment individuel."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Pour une discussion plus d\xe9taill\xe9e sur la fa\xe7on de penser l'\xe9tat normalis\xe9, voir ",(0,r.kt)("a",{parentName:"p",href:"https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape"},(0,r.kt)("inlineCode",{parentName:"a"},"cette page de la documentation Redux")),".")),(0,r.kt)("p",null,"Cela signifie finalement que nous allons diviser notre ",(0,r.kt)("inlineCode",{parentName:"p"},"todoListState")," en deux:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Un tableau d'ID de t\xe2che"),(0,r.kt)("li",{parentName:"ul"},"Un mappage de l'ID de t\xe2che aux donn\xe9es de ces t\xe2ches")),(0,r.kt)("p",null,"Le tableau des ID des t\xe2ches peut \xeatre impl\xe9ment\xe9 en utilisant un atome comme ceci:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const todoListItemIdsState = atom({\n  key: 'todoListItemIdsState',\n  default: [],\n});\n")),(0,r.kt)("p",null,"Pour impl\xe9menter un mappage de l'ID d'\xe9l\xe9ment aux donn\xe9es de cet \xe9l\xe9ment, Recoil fournit une m\xe9thode utilitaire qui nous permet de cr\xe9er dynamiquement un mappage de l'ID \xe0 l'atome. Cet utilitaire est ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/atomFamily"},(0,r.kt)("inlineCode",{parentName:"a"},"atomFamily()")),"."),(0,r.kt)("h3",{id:"atomfamily-"},(0,r.kt)("inlineCode",{parentName:"h3"},"atomFamily ()")),(0,r.kt)("p",null,"Nous utilisons la fonction ",(0,r.kt)("inlineCode",{parentName:"p"},"atomFamily()")))}m.isMDXComponent=!0}}]);