"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[8620],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,f=d["".concat(l,".").concat(m)]||d[m]||c[m]||s;return n?a.createElement(f,r(r({ref:t},p),{},{components:n})):a.createElement(f,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var u=2;u<s;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5381:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return p},default:function(){return d}});var a=n(7462),i=n(3366),s=(n(7294),n(3905)),r=["components"],o={title:"class Snapshot",sidebar_label:"Snapshot"},l=void 0,u={unversionedId:"api-reference/core/Snapshot",id:"api-reference/core/Snapshot",title:"class Snapshot",description:"Un objet Snapshot (instan\xe9) repr\xe9sente un instantan\xe9 immuable de l'\xe9tat de Recoil atomes. Il est destin\xe9 \xe0 normaliser l'API pour observer, inspecter et g\xe9rer l'\xe9tat Recoil global. Il est surtout utile pour les outils de d\xe9veloppement, la synchronisation globale de l'\xe9tat, la navigation dans l'historique, etc.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/api-reference/core/Snapshot.md",sourceDirName:"api-reference/core",slug:"/api-reference/core/Snapshot",permalink:"/fr/docs/api-reference/core/Snapshot",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/i18n/fr/docusaurus-plugin-content-docs/current/api-reference/core/Snapshot.md",tags:[],version:"current",frontMatter:{title:"class Snapshot",sidebar_label:"Snapshot"},sidebar:"docs",previous:{title:"useRecoilCallback()",permalink:"/fr/docs/api-reference/core/useRecoilCallback"},next:{title:"useRecoilTransactionObserver()",permalink:"/fr/docs/api-reference/core/useRecoilTransactionObserver"}},p=[{value:"Obtenir des instantan\xe9s",id:"obtenir-des-instantan\xe9s",children:[{value:"Crochets",id:"crochets",children:[],level:3},{value:"Cr\xe9er un instantan\xe9",id:"cr\xe9er-un-instantan\xe9",children:[],level:3}],level:2},{value:"Lecture des instantan\xe9s",id:"lecture-des-instantan\xe9s",children:[{value:"Exemple",id:"exemple",children:[],level:3}],level:2},{value:"Transformer les instantan\xe9s",id:"transformer-les-instantan\xe9s",children:[],level:2},{value:"Acc\xe9der \xe0 un instantan\xe9",id:"acc\xe9der-\xe0-un-instantan\xe9",children:[],level:2},{value:"Outils de d\xe9veloppement",id:"outils-de-d\xe9veloppement",children:[{value:"ID des instantan\xe9s",id:"id-des-instantan\xe9s",children:[],level:3},{value:"\xc9num\xe9rer les atomes et les s\xe9lecteurs",id:"\xe9num\xe9rer-les-atomes-et-les-s\xe9lecteurs",children:[],level:3},{value:"Informations de d\xe9bogage",id:"informations-de-d\xe9bogage",children:[],level:3}],level:2},{value:"Initialisation de l&#39;\xe9tat",id:"initialisation-de-l\xe9tat",children:[],level:2}],c={toc:p};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Un objet ",(0,s.kt)("inlineCode",{parentName:"p"},"Snapshot")," (instan\xe9) repr\xe9sente un instantan\xe9 immuable de l'\xe9tat de Recoil ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},"atomes"),". Il est destin\xe9 \xe0 normaliser l'API pour observer, inspecter et g\xe9rer l'\xe9tat Recoil global. Il est surtout utile pour les outils de d\xe9veloppement, la synchronisation globale de l'\xe9tat, la navigation dans l'historique, etc."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"class Snapshot {\n  // Accessors to inspect snapshot state\n  getLoadable: <T>(RecoilValue<T>) => Loadable<T>;\n  getPromise: <T>(RecoilValue<T>) => Promise<T>;\n\n  // API to transform snapshots for transactions\n  map: (MutableSnapshot => void) => Snapshot;\n  asyncMap: (MutableSnapshot => Promise<void>) => Promise<Snapshot>;\n\n  // Developer Tools API\n  getID: () => SnapshotID;\n  getNodes_UNSTABLE: ({\n    isModified?: boolean,\n  } | void) => Iterable<RecoilValue<mixed>>;\n  getInfo_UNSTABLE: <T>(RecoilValue<T>) => {...};\n}\n\nfunction snapshot_UNSTABLE(initializeState?: (MutableSnapshot => void)): Snapshot\n")),(0,s.kt)("h2",{id:"obtenir-des-instantan\xe9s"},"Obtenir des instantan\xe9s"),(0,s.kt)("h3",{id:"crochets"},"Crochets"),(0,s.kt)("p",null,"Recoil fournit les hooks suivants pour obtenir des instantan\xe9s en fonction de l'\xe9tat actuel:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilCallback"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilCallback()"))," - Acc\xe8s asynchrone \xe0 un snapshot"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilSnapshot"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilSnapshot()"))," - Acc\xe8s synchrone \xe0 un snapshot"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useRecoilTransactionObserver"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilTransactionObserver_UNSTABLE()"))," - Abonnez-vous aux Snapshots pour tous les changements d'\xe9tat")),(0,s.kt)("h3",{id:"cr\xe9er-un-instantan\xe9"},"Cr\xe9er un instantan\xe9"),(0,s.kt)("p",null,"Vous pouvez \xe9galement cr\xe9er un instantan\xe9 frais en utilisant la fabrique ",(0,s.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE()"),", qui accepte une fonction d'initialisation facultative. Cela peut \xeatre utilis\xe9 pour ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/testing"},"tester")," ou pour \xe9valuer des s\xe9lecteurs en dehors d'un contexte React."),(0,s.kt)("h2",{id:"lecture-des-instantan\xe9s"},"Lecture des instantan\xe9s"),(0,s.kt)("p",null,"Les instantan\xe9s sont en lecture seule par rapport \xe0 l'\xe9tat de l'atome. Ils peuvent \xeatre utilis\xe9s pour lire l'\xe9tat de l'atome et \xe9valuer l'\xe9tat d\xe9riv\xe9 des s\xe9lecteurs. ",(0,s.kt)("inlineCode",{parentName:"p"},"getLoadable()")," fournit un ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/Loadable"},(0,s.kt)("inlineCode",{parentName:"a"},"Loadable"))," avec l'\xe9tat de l'atome ou du s\xe9lecteur dans cet instantan\xe9. La m\xe9thode ",(0,s.kt)("inlineCode",{parentName:"p"},"getPromise()")," peut \xeatre utilis\xe9e pour attendre la valeur \xe9valu\xe9e des s\xe9lecteurs asynchrones, afin que vous puissiez voir quelle serait la valeur bas\xe9e sur l'\xe9tat de l'atome statique."),(0,s.kt)("h3",{id:"exemple"},"Exemple"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'function MyComponent() {\n  const logState = useRecoilCallback(({snapshot}) => () => {\n    console.log("State: ", snapshot.getLoadable(myAtom).contents);\n\n    const newSnapshot = snapshot.map(({set}) => set(myAtom, 42));\n  });\n}\n')),(0,s.kt)("h2",{id:"transformer-les-instantan\xe9s"},"Transformer les instantan\xe9s"),(0,s.kt)("p",null,"Il existe des cas o\xf9 vous souhaiterez peut-\xeatre muter un instantan\xe9. Bien que les instantan\xe9s soient immuables, ils disposent de m\xe9thodes pour se mapper avec un ensemble de transformations vers un nouvel instantan\xe9 immuable. Les m\xe9thodes de mappage prennent un rappel qui re\xe7oit un MutableSnapshot, qui est mut\xe9 tout au long du rappel et deviendra finalement le nouvel instantan\xe9 retourn\xe9 par l'op\xe9ration de mappage."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"class MutableSnapshot {\n  set: <T>(RecoilState<T>, T | DefaultValue | (T => T | DefaultValue)) => void;\n  reset: <T>(RecoilState<T>) => void;\n}\n")),(0,s.kt)("p",null,"Notez que ",(0,s.kt)("inlineCode",{parentName:"p"},"set()")," et ",(0,s.kt)("inlineCode",{parentName:"p"},"reset()")," ont la m\xeame signature que les rappels fournis \xe0 la propri\xe9t\xe9 ",(0,s.kt)("inlineCode",{parentName:"p"},"set")," d'un s\xe9lecteur inscriptible, mais ils n'affectent que le nouvel instantan\xe9, pas l'\xe9tat actuel."),(0,s.kt)("h2",{id:"acc\xe9der-\xe0-un-instantan\xe9"},"Acc\xe9der \xe0 un instantan\xe9"),(0,s.kt)("p",null,"Le crochet suivant peut \xeatre utilis\xe9 pour naviguer de l'\xe9tat de Recoil actuel vers le ",(0,s.kt)("inlineCode",{parentName:"p"},"Snapshot")," fourni:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/api-reference/core/useGotoRecoilSnapshot"},(0,s.kt)("inlineCode",{parentName:"a"},"useGotoRecoilSnapshot()"))," - Mettre \xe0 jour l'\xe9tat actuel pour qu'il corresponde \xe0 un instantan\xe9")),(0,s.kt)("h2",{id:"outils-de-d\xe9veloppement"},"Outils de d\xe9veloppement"),(0,s.kt)("p",null,"Les instantan\xe9s fournissent des m\xe9thodes utiles pour ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/dev-tools"},"cr\xe9er des outils de d\xe9veloppement")," ou pour d\xe9boguer des capacit\xe9s avec Recoil. Cette API est toujours en \xe9volution, et donc marqu\xe9e comme ",(0,s.kt)("inlineCode",{parentName:"p"},"_UNSTABLE"),", alors que nous travaillons sur les outils de d\xe9veloppement initiaux."),(0,s.kt)("h3",{id:"id-des-instantan\xe9s"},"ID des instantan\xe9s"),(0,s.kt)("p",null,"Chaque \xe9tat valid\xe9 ou snapshot mut\xe9 a un ID de version opaque unique qui peut \xeatre obtenu via ",(0,s.kt)("inlineCode",{parentName:"p"},"getID()"),". Cela peut \xeatre utilis\xe9 pour d\xe9tecter quand nous sommes revenus \xe0 un instantan\xe9 pr\xe9c\xe9dent via ",(0,s.kt)("inlineCode",{parentName:"p"},"useGotoRecoilSnapshot()"),"."),(0,s.kt)("h3",{id:"\xe9num\xe9rer-les-atomes-et-les-s\xe9lecteurs"},"\xc9num\xe9rer les atomes et les s\xe9lecteurs"),(0,s.kt)("p",null,"La m\xe9thode ",(0,s.kt)("inlineCode",{parentName:"p"},"getNodes_UNSTABLE()")," peut \xeatre utilis\xe9e pour it\xe9rer tous les atomes et s\xe9lecteurs qui \xe9taient utilis\xe9s pour cet instantan\xe9. Des atomes, des s\xe9lecteurs et des familles peuvent \xeatre cr\xe9\xe9s \xe0 tout moment. Cependant, ils n'appara\xeetront dans l'instantan\xe9 que s'ils sont r\xe9ellement utilis\xe9s. Les atomes et les s\xe9lecteurs peuvent \xeatre supprim\xe9s des instantan\xe9s d'\xe9tat suivants s'ils ne sont plus utilis\xe9s."),(0,s.kt)("p",null,"Un drapeau optionnel ",(0,s.kt)("inlineCode",{parentName:"p"},"isModified")," peut \xeatre sp\xe9cifi\xe9 pour ne renvoyer que les atomes qui ont \xe9t\xe9 modifi\xe9s depuis la derni\xe8re transaction."),(0,s.kt)("h3",{id:"informations-de-d\xe9bogage"},"Informations de d\xe9bogage"),(0,s.kt)("p",null,"La m\xe9thode ",(0,s.kt)("inlineCode",{parentName:"p"},"getInfo_UNSTABLE ()")," fournit des informations de d\xe9bogage suppl\xe9mentaires pour les atomes et les s\xe9lecteurs. Les informations de d\xe9bogage fournies \xe9voluent, mais peuvent inclure:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"loadable")," - Un chargeable avec l'\xe9tat actuel. Contrairement aux m\xe9thodes comme ",(0,s.kt)("inlineCode",{parentName:"li"},"getLoadable()"),", cette m\xe9thode ne mute pas du tout l'instantan\xe9. Il fournit l'\xe9tat actuel et n'initialisera pas de nouveaux atomes/s\xe9lecteurs, n'effectuera aucune nouvelle \xe9valuation de s\xe9lecteur ou ne mettra \xe0 jour aucune d\xe9pendance ou abonnement."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"isSet")," - Vrai s'il s'agit d'un atome avec une valeur explicite stock\xe9e dans l'\xe9tat de l'instantan\xe9. Faux s'il s'agit d'un s\xe9lecteur ou qu'il s'agit d'une valeur par d\xe9faut."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"isModified")," - Vrai s'il s'agit d'un atome qui a \xe9t\xe9 modifi\xe9 depuis la derni\xe8re transaction."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"type")," - Soit un ",(0,s.kt)("inlineCode",{parentName:"li"},"atome"),", soit un ",(0,s.kt)("inlineCode",{parentName:"li"},"s\xe9lecteur")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"deps")," - Un it\xe9rateur sur les atomes ou s\xe9lecteurs dont d\xe9pend ce n\u0153ud."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"abonn\xe9s")," - Informations sur ce qui s'abonne \xe0 ce n\u0153ud pour cet instantan\xe9. D\xe9tails en cours de d\xe9veloppement.")),(0,s.kt)("p",null,"Ceci est similaire au hook ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useGetRecoilValueInfo"},(0,s.kt)("inlineCode",{parentName:"a"},"useGetRecoilValueInfo_UNSTABLE()")),", mais les informations fournies sont bas\xe9es sur l'\xe9tat du ",(0,s.kt)("inlineCode",{parentName:"p"},"Snapshot")," en place de l'\xe9tat courant. Il n'est pas possible d'obtenir des informations non-associ\xe9es \xe0 un snapshot Recoil, tel que souscrire \xe0 un composant React."),(0,s.kt)("h2",{id:"initialisation-de-l\xe9tat"},"Initialisation de l'\xe9tat"),(0,s.kt)("p",null,"Le composant ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/RecoilRoot"},(0,s.kt)("inlineCode",{parentName:"a"},"<RecoilRoot>"))," et l'usine ",(0,s.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE ()")," prennent un accessoire optionnel ",(0,s.kt)("inlineCode",{parentName:"p"},"initializeState")," pour initialiser l'\xe9tat via un",(0,s.kt)("inlineCode",{parentName:"p"}," MutableSnapshot"),". Cela peut \xeatre utile pour charger l'\xe9tat persistant lorsque vous connaissez tous les atomes \xe0 l'avance et est compatible avec le rendu c\xf4t\xe9 serveur o\xf9 l'\xe9tat doit \xeatre configur\xe9 de mani\xe8re synchrone avec le rendu initial. Pour l'initialisation / la persistance par atome et la facilit\xe9 de travailler avec des atomes dynamiques, consid\xe9rez les ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"Effets Atomiques")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyApp() {\n  function initializeState({set}) {\n    set(myAtom, 'foo');\n  }\n\n  return (\n    <RecoilRoot initializeState={initializeState}>\n      ...\n    </RecoilRoot>\n  );\n}\n")))}d.isMDXComponent=!0}}]);