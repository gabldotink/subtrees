"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[3604],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),m=a,d=h["".concat(l,".").concat(m)]||h[m]||p[m]||o;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5998:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return h}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"GraphQL Mutations",sidebar_label:"GraphQL Mutations"},l=void 0,u={unversionedId:"recoil-relay/graphql-mutations",id:"recoil-relay/graphql-mutations",title:"GraphQL Mutations",description:"GraphQL Mutations",source:"@site/docs/recoil-relay/graphql-mutations.md",sourceDirName:"recoil-relay",slug:"/recoil-relay/graphql-mutations",permalink:"/fr/docs/recoil-relay/graphql-mutations",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/i18n/fr/docusaurus-plugin-content-docs/current/recoil-relay/graphql-mutations.md",tags:[],version:"current",frontMatter:{title:"GraphQL Mutations",sidebar_label:"GraphQL Mutations"},sidebar:"recoil-relay",previous:{title:"GraphQL Queries",permalink:"/fr/docs/recoil-relay/graphql-queries"},next:{title:"GraphQL Subscriptions",permalink:"/fr/docs/recoil-relay/graphql-subscriptions"}},c=[{value:"GraphQL Mutations",id:"graphql-mutations",children:[],level:2},{value:"Write-through Cache",id:"write-through-cache",children:[],level:2},{value:"Local Updates",id:"local-updates",children:[],level:2}],p={toc:c};function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"graphql-mutations"},"GraphQL Mutations"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/recoil-relay/graphql-queries"},"GraphQL selectors")," will perform an initial query as well as subscribe to any changes.  You can use Relay APIs such as ",(0,o.kt)("a",{parentName:"p",href:"https://relay.dev/docs/api-reference/use-mutation"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"useMutation()")))," and ",(0,o.kt)("a",{parentName:"p",href:"https://relay.dev/docs/api-reference/commit-mutation"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"commitMutation()")))," to update the state on the server.  These changes will also sync and cause the Recoil GraphQL selectors to update.  This allows you to treat the server as the source of truth with the selector as a local cache."),(0,o.kt)("p",null,"The mutation response should select data that you want to be returned by the server when updated so it can update the local client state.  This is necessary so other GraphQL queries and Recoil selectors based on that data will re-render with the new state.  It can be a good practice to use GraphQL fragments to help ensure your queries and mutations return the same data.  For more complex updates you may need to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"updater")," option.  You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"optimisticResponse")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"optimisticUpdater")," to update the local state before getting the response to the mutation back from the server.  If there is an error the optimistic updates will be rolled back.  In any case, make sure your mutation is using the same Relay environment as your queries and selectors."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent(props) {\n  const user = useRecoilValue(userQuery(props.userID));\n  const [commitEvent] = useMutation(graphql`\n    mutation UserMutation($input: UsertNameChangeData!) {\n      user_mutation(data: $input) {\n        user {\n          id\n          name\n        }\n      }\n    }\n  `);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => {\n        commitEvent({\n          variables: {\n            input: {\n              id: props.userID,\n              name: 'New Name',\n            },\n          },\n        });\n      }}>Change Name</button>\n    </div>\n  );\n}\n")),(0,o.kt)("h2",{id:"write-through-cache"},"Write-through Cache"),(0,o.kt)("p",null,"Another pattern you can use for updating state is to treat the Recoil selector as a local write-through cache for the server.  It is a writable selector, so local updates will immediately be reflected in the UI.  If you provide ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#mutations"},(0,o.kt)("strong",{parentName:"a"},"GraphQL mutation"))," information, then updating the selector will also initiate a mutation with the server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"const userState = graphQLSelector({\n  key: 'User',\n  environment: relayFBEnvironmentKey,\n  query: graphql`\n    query UserQuery($eventID: ID!, $clientID: ClientID!) {\n      user(id: $eventID, client_id: $clientID) {\n        name\n        timestamp\n      }\n    }\n  `,\n  variables: id => ({get}) => ({id, clientID: get(clientIDAtom}),\n  mapResponse: data => data.user,\n\n  mutations: {\n    mutation: graphql`\n      mutation UserMutation($input: UserNameChangeData!) {\n        user_mutation(data: $input) {\n          user {\n            id\n            name\n          }\n        }\n      }\n    `,\n    variables: newUserData => id => ({input: {id, name: newUserData.name}}),\n  },\n});\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent() {\n  const [user, setUser] = useRecoilState(userState);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => {\n        setUser(user => ({...user, name: 'New Name'}));\n      }}>Change Name</button>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,'Note that when using Recoil as a write-through cache like this the Relay concept of "optimistic response" is not necessary for mutations since updating the selector will update the UI before the remote mutation is committed.  If there is an error from the server then the local update will be rolled back.'),(0,o.kt)("h2",{id:"local-updates"},"Local Updates"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://relay.dev/docs/guided-tour/updating-data/local-data-updates/#commitlocalupdate"},(0,o.kt)("strong",{parentName:"a"},(0,o.kt)("inlineCode",{parentName:"strong"},"commitLocalUpdate()")))," Relay API can be used for local updates to the GraphQL state without issuing a network request to update the server.  Updates will cause all relevant components subscribing to affected queries and selectors to re-render."))}h.isMDXComponent=!0}}]);