"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[430],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=m(a),d=r,f=c["".concat(s,".").concat(d)]||c[d]||u[d]||i;return a?n.createElement(f,o(o({ref:t},p),{},{components:a})):n.createElement(f,o({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var m=2;m<i;m++)o[m]=a[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},7175:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return m},toc:function(){return p},default:function(){return c}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],l={title:"atomFamily(options)",sidebar_label:"atomFamily()"},s=void 0,m={unversionedId:"api-reference/utils/atomFamily",id:"api-reference/utils/atomFamily",title:"atomFamily(options)",description:"Returns a function that returns a writeable RecoilState atom.",source:"@site/docs/api-reference/utils/atomFamily.md",sourceDirName:"api-reference/utils",slug:"/api-reference/utils/atomFamily",permalink:"/docs/api-reference/utils/atomFamily",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/api-reference/utils/atomFamily.md",tags:[],version:"current",frontMatter:{title:"atomFamily(options)",sidebar_label:"atomFamily()"},sidebar:"docs",previous:{title:"isRecoilValue()",permalink:"/docs/api-reference/core/isRecoilValue"},next:{title:"selectorFamily()",permalink:"/docs/api-reference/utils/selectorFamily"}},p=[{value:"Parameter Type",id:"parameter-type",children:[],level:2},{value:"Example",id:"example",children:[],level:2},{value:"Family Defaults",id:"family-defaults",children:[],level:2},{value:"Subscriptions",id:"subscriptions",children:[],level:2},{value:"Scoped Atoms",id:"scoped-atoms",children:[],level:2},{value:"Persistence",id:"persistence",children:[],level:2}],u={toc:p};function c(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Returns a function that returns a writeable ",(0,i.kt)("inlineCode",{parentName:"p"},"RecoilState")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},"atom"),"."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"function atomFamily<T, P: Parameter>({\n  key: string,\n\n  default?:\n    | T\n    | Promise<T>\n    | Loadable<T>\n    | WrappedValue<T>\n    | RecoilValue<T>\n    | (P => T | Promise<T> | Loadable<T> | WrappedValue<T> | RecoilValue<T>),\n\n  effects?:\n    | $ReadOnlyArray<AtomEffect<T>>\n    | (P => $ReadOnlyArray<AtomEffect<T>>),\n\n  dangerouslyAllowMutability?: boolean,\n}): P => RecoilState<T>\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key")," - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default")," - The initial value of the atom.  Like an atom, it may either be a value directly or a ",(0,i.kt)("inlineCode",{parentName:"li"},"Promise"),", ",(0,i.kt)("a",{parentName:"li",href:"/docs/api-reference/core/Loadable"},(0,i.kt)("inlineCode",{parentName:"a"},"Loadable")),", wrapped value, or another atom/selector that represents the default value.  Atom families can also be a function that is passed a parameter and returns the default for that family member.  If not provided, the atom will start in a pending state and trigger Suspense."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"effects")," - An optional array, or callback to get the array based on the family parameter, of ",(0,i.kt)("a",{parentName:"li",href:"/docs/guides/atom-effects"},"Atom Effects"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dangerouslyAllowMutability")," - Recoil depends on atom state changes to know when to notify components that use the atoms to re-render.  If an atom's value were mutated, it may bypass this and cause state to change without properly notifying subscribing components.  To help protect against this all stored values are frozen.  In some cases it may be desireable to override this using this option.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"atom")," represents a piece of state with ",(0,i.kt)("em",{parentName:"p"},"Recoil"),". An atom is created and registered per ",(0,i.kt)("inlineCode",{parentName:"p"},"<RecoilRoot>")," by your app. But, what if your state isn\u2019t global? What if your state is associated with a particular instance of a control, or with a particular element? For example, maybe your app is a UI prototyping tool where the user can dynamically add elements and each element has state, such as its position. Ideally, each element would get its own atom of state. You could implement this yourself via a memoization pattern. But, ",(0,i.kt)("em",{parentName:"p"},"Recoil")," provides this pattern for you with the ",(0,i.kt)("inlineCode",{parentName:"p"},"atomFamily()")," utility. An Atom Family represents a collection of atoms. When you call ",(0,i.kt)("inlineCode",{parentName:"p"},"atomFamily()")," it will return a function which provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"RecoilState")," atom based on the parameters you pass in."),(0,i.kt)("h2",{id:"parameter-type"},"Parameter Type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"type Primitive = void | null | boolean | number | string;\ninterface HasToJSON {\n  toJSON(): Parameter;\n}\ntype Parameter =\n  | Primitive\n  | HasToJSON\n  | $ReadOnlyArray<Parameter>\n  | $ReadOnly<{[string]: Parameter}>\n  | $ReadOnlySet<Parameter>\n  | $ReadOnlyMap<Parameter, Parameter>;\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"atomFamily()")," essentially provides a map from the parameter to an atom.  You only need to provide a single key for the atom family and it will generate a unique key for each underlying atom.  These atom keys can be used for persistence, and so must be stable across application executions."),(0,i.kt)("p",null,"There are restrictions on the type you can use as the family ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameter"),".  They may be generated at different callsites and we want equivalent parameters to reference the same underlying atom.  Therefore, parameters are compared using value-equality and must be serializable.  To be serializable it must be either:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A primitive value"),(0,i.kt)("li",{parentName:"ul"},"An array, object, ",(0,i.kt)("inlineCode",{parentName:"li"},"Map"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"Set")," of serializable values"),(0,i.kt)("li",{parentName:"ul"},"Contain a ",(0,i.kt)("inlineCode",{parentName:"li"},"toJSON()")," method which returns a serializable value, similar to ",(0,i.kt)("inlineCode",{parentName:"li"},"JSON.stringify()"))),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const elementPositionStateFamily = atomFamily({\n  key: 'ElementPosition',\n  default: [0, 0],\n});\n\nfunction ElementListItem({elementID}) {\n  const position = useRecoilValue(elementPositionStateFamily(elementID));\n  return (\n    <div>\n      Element: {elementID}\n      Position: {position}\n    </div>\n  );\n}\n")),(0,i.kt)("h2",{id:"family-defaults"},"Family Defaults"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"atomFamily()")," takes almost the same options as a simple ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},(0,i.kt)("inlineCode",{parentName:"a"},"atom()")),".  However, the default value can also be parameterized. That means you could provide a function which takes the parameter value and returns the actual default value.  For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const myAtomFamily = atomFamily({\n  key: \u2018MyAtom\u2019,\n  default: param => defaultBasedOnParam(param),\n});\n")),(0,i.kt)("p",null,"For dynamic defaults based on other state use a ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/selectorFamily"},(0,i.kt)("inlineCode",{parentName:"a"},"selectorFamily()")),", which also has access to the parameter value.  Don't just use ",(0,i.kt)("inlineCode",{parentName:"p"},"selector()")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"atomFamily()")," defaults, as it would produce duplicate keys."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const myAtomFamily = atomFamily({\n  key: \u2018MyAtom\u2019,\n  default: selectorFamily({\n    key: 'MyAtom/Default',\n    get: param => ({get}) => {\n      const otherAtomValue = get(otherState);\n      return computeDefaultUsingParam(otherAtomValue, param);\n    },\n  }),\n});\n")),(0,i.kt)("h2",{id:"subscriptions"},"Subscriptions"),(0,i.kt)("p",null,"One advantage of using this pattern for separate atoms for each element over trying to store a single atom with a map of state for all elements is that they all maintain their own individual subscriptions. So, updating the value for one element will only cause React components that have subscribed to just that atom to update."),(0,i.kt)("h2",{id:"scoped-atoms"},"Scoped Atoms"),(0,i.kt)("p",null,'Sometimes you may want to "scope" atom state by some other prop, React Context, or piece of state.  For example:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const viewWidthForPaneState = atomFamily<number, PaneID>({\n  key: 'ViewWidthForPane',\n  default: 42,\n});\n\nfunction PaneView() {\n  const paneID = useContext(PaneIDContext);\n  const viewWidth = useRecoilValue(viewWidthForPaneState(paneID));\n  ...\n}\n")),(0,i.kt)("p",null,"If you want to scope by some other Recoil state and wish to avoid looking up the scope parameter at every call site, it can be a useful pattern to use a wrapper ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/core/selector"},(0,i.kt)("inlineCode",{parentName:"a"},"selector()")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const viewWidthState = selector({\n  key: 'ViewWidth',\n  get: ({get}) => viewWidthForPane(get(currentPaneState)),\n  set: ({get, set}, newValue) => set(viewWidthForPane(get(currentPaneState)), newValue),\n});\n\nfunction PaneView() {\n  const viewWidth = useRecoilValue(viewWidthState);\n  ...\n}\n")),(0,i.kt)("h2",{id:"persistence"},"Persistence"),(0,i.kt)("p",null,"Persistence observers and ",(0,i.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"atom effects")," will sync the state for each parameter value as a distinct atom with a unique key based on serialization of the parameter value used. Therefore, it is important to ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/atomFamily#parameter-type"},"serializable parameters"),". Custom classes or functions are not allowed."))}c.isMDXComponent=!0}}]);