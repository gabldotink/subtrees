"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[1671],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=s(n),d=r,y=m["".concat(c,".").concat(d)]||m[d]||p[d]||l;return n?a.createElement(y,i(i({ref:t},u),{},{components:n})):a.createElement(y,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6967:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return u},default:function(){return m}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),i=["components"],o={title:"selectorFamily(options)",sidebar_label:"selectorFamily()"},c=void 0,s={unversionedId:"api-reference/utils/selectorFamily",id:"api-reference/utils/selectorFamily",title:"selectorFamily(options)",description:"Returns a function that returns a read-only RecoilValueReadOnly or writeable RecoilState selector.",source:"@site/docs/api-reference/utils/selectorFamily.md",sourceDirName:"api-reference/utils",slug:"/api-reference/utils/selectorFamily",permalink:"/docs/api-reference/utils/selectorFamily",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/api-reference/utils/selectorFamily.md",tags:[],version:"current",frontMatter:{title:"selectorFamily(options)",sidebar_label:"selectorFamily()"},sidebar:"docs",previous:{title:"atomFamily()",permalink:"/docs/api-reference/utils/atomFamily"},next:{title:"constSelector()",permalink:"/docs/api-reference/utils/constSelector"}},u=[{value:"Parameter Type",id:"parameter-type",children:[],level:2},{value:"Example",id:"example",children:[],level:2},{value:"Async Query Example",id:"async-query-example",children:[],level:2},{value:"Destructuring Example",id:"destructuring-example",children:[],level:2},{value:"Cache policy configuration",id:"cache-policy-configuration",children:[],level:2}],p={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Returns a function that returns a read-only ",(0,l.kt)("inlineCode",{parentName:"p"},"RecoilValueReadOnly")," or writeable ",(0,l.kt)("inlineCode",{parentName:"p"},"RecoilState")," selector."),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"selectorFamily")," is a powerful pattern that is similar to a ",(0,l.kt)("a",{parentName:"p",href:"/docs/api-reference/core/selector"},(0,l.kt)("inlineCode",{parentName:"a"},"selector")),", but allows you to pass parameters to the ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"set")," callbacks of a ",(0,l.kt)("inlineCode",{parentName:"p"},"selector"),".  The ",(0,l.kt)("inlineCode",{parentName:"p"},"selectorFamily()")," utility returns a function which can be called with user-defined parameters and returns a selector. Each unique parameter value will return the same memoized selector instance."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Read-only selector family:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"function selectorFamily<T, P: Parameter>({\n  key: string,\n\n  get: P => ({\n    get: GetRecoilValue\n    getCallback: GetCallback<T>,\n  }) =>\n    T | Promise<T> | Loadable<T> | WrappedValue<T> | RecoilValue<T>,\n\n  dangerouslyAllowMutability?: boolean,\n}): P => RecoilValueReadOnly<T>\n")),(0,l.kt)("p",null,"Writable selector family:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"function selectorFamily<T, P: Parameter>({\n  key: string,\n\n  get: P => ({\n    get: GetRecoilValue\n    getCallback: GetCallback<T>,\n  }) =>\n    T | Promise<T> | Loadable<T> | WrappedValue<T> | RecoilValue<T>,\n\n  set: P => (\n    {\n      get: GetRecoilValue,\n      set: SetRecoilValue,\n      reset: ResetRecoilValue,\n    },\n    newValue: T | DefaultValue,\n  ) => void,\n\n  dangerouslyAllowMutability?: boolean,\n\n  cachePolicy_UNSTABLE?: CachePolicy,\n}): P => RecoilState<T>\n")),(0,l.kt)("p",null,"Where"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"type ValueOrUpdater<T> =  T | DefaultValue | ((prevValue: T) => T | DefaultValue);\n\ntype GetRecoilValue = <T>(RecoilValue<T>) => T;\ntype SetRecoilValue = <T>(RecoilState<T>, ValueOrUpdater<T>) => void;\ntype ResetRecoilValue = <T>(RecoilState<T>) => void;\n\ntype GetCallback<T> =\n  <Args, Return>(\n    callback: ({node: RecoilState<T>, ...CallbackInterface}) => (...Args) => Return,\n  ) => (...Args) => Return;\n\ntype CachePolicy =\n  | {eviction: 'lru', maxSize: number}\n  | {eviction: 'keep-all'}\n  | {eviction: 'most-recent'};\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"get")," - A function that is passed an object of named callbacks that returns the value of the selector, the same as the ",(0,l.kt)("inlineCode",{parentName:"li"},"selector()")," interface. This is wrapped by a function which is passed the parameter from calling the selector family function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"set?")," - An optional function that will produce writeable selectors when provided. It should be a function that takes an object of named callbacks, same as the ",(0,l.kt)("inlineCode",{parentName:"li"},"selector()")," interface. This is again wrapped by another function with gets the parameters from calling the selector family function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cachePolicy_UNSTABLE")," - Defines the behavior of the internal selector cache for ",(0,l.kt)("strong",{parentName:"li"},"the invidual selectors")," that make up the family (it does not control the number of selectors that are stored in the family). Can be useful to control the memory footprint in apps that have selectors with many changing dependencies.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"eviction")," - can be set to ",(0,l.kt)("inlineCode",{parentName:"li"},"lru")," (which requires that a ",(0,l.kt)("inlineCode",{parentName:"li"},"maxSize")," is set), ",(0,l.kt)("inlineCode",{parentName:"li"},"keep-all")," (default), or ",(0,l.kt)("inlineCode",{parentName:"li"},"most-recent"),". An ",(0,l.kt)("inlineCode",{parentName:"li"},"lru")," cache will evict the least-recently-used value from the selector cache when the size of the cache exceeds ",(0,l.kt)("inlineCode",{parentName:"li"},"maxSize"),". A ",(0,l.kt)("inlineCode",{parentName:"li"},"keep-all")," policy will mean all selector dependencies and their values will be indefinitely stored in the selector cache. A ",(0,l.kt)("inlineCode",{parentName:"li"},"most-recent")," policy will use a cache of size 1 and will retain only the most recently saved set of dependencies and their values."),(0,l.kt)("li",{parentName:"ul"},"Note the ",(0,l.kt)("inlineCode",{parentName:"li"},"maxSize")," property used alongside ",(0,l.kt)("inlineCode",{parentName:"li"},"lru")," does not control the max size of the family itself, it only controls the eviction policy used in the invidiual selectors that make up the family."),(0,l.kt)("li",{parentName:"ul"},"Note the cache stores the values of the selector based on a key containing all dependencies and their values. This means the size of the internal selector cache depends on both the size of the selector values as well as the number of unique values of all dependencies."),(0,l.kt)("li",{parentName:"ul"},"Note the default eviction policy (currently ",(0,l.kt)("inlineCode",{parentName:"li"},"keep-all"),") may change in the future.")))),(0,l.kt)("hr",null),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"selectorFamily()")," essentially provides a map from the parameter to a selector.  You only need to provide a single key for the atom family and it will generate a unique key for each underlying selector."),(0,l.kt)("h2",{id:"parameter-type"},"Parameter Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"type Primitive = void | null | boolean | number | string;\ninterface HasToJSON {\n  toJSON(): Parameter;\n}\ntype Parameter =\n  | Primitive\n  | HasToJSON\n  | $ReadOnlyArray<Parameter>\n  | $ReadOnly<{[string]: Parameter}>\n  | $ReadOnlySet<Parameter>\n  | $ReadOnlyMap<Parameter, Parameter>;\n")),(0,l.kt)("p",null,"There are restrictions on the type you can use as the family ",(0,l.kt)("inlineCode",{parentName:"p"},"Parameter"),".  They may be generated at different callsites and we want equivalent parameters to reference the same underlying selector.  Therefore, parameters are compared using value-equality and must be serializable.  Using functions or mutable objects, such as Promises, in parameters is problematic.  To be serializable it must be either:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A primitive value"),(0,l.kt)("li",{parentName:"ul"},"An array, object, ",(0,l.kt)("inlineCode",{parentName:"li"},"Map"),", or ",(0,l.kt)("inlineCode",{parentName:"li"},"Set")," of serializable values"),(0,l.kt)("li",{parentName:"ul"},"Contain a ",(0,l.kt)("inlineCode",{parentName:"li"},"toJSON()")," method which returns a serializable value, similar to ",(0,l.kt)("inlineCode",{parentName:"li"},"JSON.stringify()"))),(0,l.kt)("h2",{id:"example"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"const myNumberState = atom({\n  key: 'MyNumber',\n  default: 2,\n});\n\nconst myMultipliedState = selectorFamily({\n  key: 'MyMultipliedNumber',\n  get: (multiplier) => ({get}) => {\n    return get(myNumberState) * multiplier;\n  },\n\n  // optional set\n  set: (multiplier) => ({set}, newValue) => {\n    set(myNumberState, newValue / multiplier);\n  },\n});\n\nfunction MyComponent() {\n  // defaults to 2\n  const number = useRecoilValue(myNumberState);\n\n  // defaults to 200\n  const multipliedNumber = useRecoilValue(myMultipliedState(100));\n\n  return <div>...</div>;\n}\n")),(0,l.kt)("h2",{id:"async-query-example"},"Async Query Example"),(0,l.kt)("p",null,'Selector Families are also useful to use for passing parameters to queries.  Note that using a selector to abstract queries like this should still be "pure" functions which always return the same result for a given set of inputs and dependency values.  See ',(0,l.kt)("a",{parentName:"p",href:"/docs/guides/asynchronous-data-queries"},"this guide")," for more examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"const myDataQuery = selectorFamily({\n  key: 'MyDataQuery',\n  get: (queryParameters) => async ({get}) => {\n    const response = await asyncDataRequest(queryParameters);\n    if (response.error) {\n      throw response.error;\n    }\n    return response.data;\n  },\n});\n\nfunction MyComponent() {\n  const data = useRecoilValue(myDataQuery({userID: 132}));\n  return <div>...</div>;\n}\n")),(0,l.kt)("h2",{id:"destructuring-example"},"Destructuring Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jsx"},"const formState = atom({\n  key: 'formState',\n  default: {\n    field1: \"1\",\n    field2: \"2\",\n    field3: \"3\",\n  },\n});\n\nconst formFieldState = selectorFamily({\n  key: 'FormField',\n  get: field => ({get}) => get(formState)[field],\n  set: field => ({set}, newValue) =>\n    set(formState, prevState => ({...prevState, [field]: newValue})),\n});\n\nconst Component1 = () => {\n  const [value, onChange] = useRecoilState(formFieldState('field1'));\n  return (\n    <>\n      <input value={value} onChange={onChange} />\n      <Component2 />\n    </>\n  );\n}\n\nconst Component2 = () => {\n  const [value, onChange] = useRecoilState(formFieldState('field2'));\n  return (\n    <input value={value} onChange={onChange} />\n  );\n}\n")),(0,l.kt)("h2",{id:"cache-policy-configuration"},"Cache policy configuration"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"cachePolicy_UNSTABLE")," property allows you to configure the caching behavior of ",(0,l.kt)("strong",{parentName:"p"},"individual selectors")," that make up the family. This property can be useful for reducing memory in applications that have a large number of selectors that have a large number of changing dependencies.  Please see the ",(0,l.kt)("a",{parentName:"p",href:"/docs/api-reference/core/selector#cache-policy-configuration"},"selector cache policy configuration documentation"),"."))}m.isMDXComponent=!0}}]);