"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","collapsed":true,"collapsible":true,"label":"Introduction","items":[{"type":"link","label":"Motivation","href":"/docs/introduction/motivation","docId":"introduction/motivation"},{"type":"link","label":"Core Concepts","href":"/docs/introduction/core-concepts","docId":"introduction/core-concepts"},{"type":"link","label":"Installation","href":"/docs/introduction/installation","docId":"introduction/installation"},{"type":"link","label":"Getting Started","href":"/docs/introduction/getting-started","docId":"introduction/getting-started"}]},{"type":"category","collapsed":true,"collapsible":true,"label":"Basic Tutorial","items":[{"type":"link","label":"Intro","href":"/docs/basic-tutorial/intro","docId":"basic-tutorial/intro"},{"type":"link","label":"Atoms","href":"/docs/basic-tutorial/atoms","docId":"basic-tutorial/atoms"},{"type":"link","label":"Selectors","href":"/docs/basic-tutorial/selectors","docId":"basic-tutorial/selectors"}]},{"type":"category","collapsed":true,"collapsible":true,"label":"Guides","items":[{"type":"link","label":"Asynchronous Data Queries","href":"/docs/guides/asynchronous-data-queries","docId":"guides/asynchronous-data-queries"},{"type":"link","label":"Atom Effects","href":"/docs/guides/atom-effects","docId":"guides/atom-effects"},{"type":"link","label":"Testing","href":"/docs/guides/testing","docId":"guides/testing"},{"type":"link","label":"Transitions","href":"/docs/guides/transitions","docId":"guides/transitions"},{"type":"link","label":"Dev Tools","href":"/docs/guides/dev-tools","docId":"guides/dev-tools"}]},{"type":"category","collapsed":true,"collapsible":true,"label":"API Reference","items":[{"type":"link","label":"<RecoilRoot>","href":"/docs/api-reference/core/RecoilRoot","docId":"api-reference/core/RecoilRoot"},{"type":"category","collapsed":true,"collapsible":true,"label":"State","items":[{"type":"link","label":"atom()","href":"/docs/api-reference/core/atom","docId":"api-reference/core/atom"},{"type":"link","label":"selector()","href":"/docs/api-reference/core/selector","docId":"api-reference/core/selector"},{"type":"link","label":"Loadable","href":"/docs/api-reference/core/Loadable","docId":"api-reference/core/Loadable"},{"type":"link","label":"useRecoilState()","href":"/docs/api-reference/core/useRecoilState","docId":"api-reference/core/useRecoilState"},{"type":"link","label":"useRecoilValue()","href":"/docs/api-reference/core/useRecoilValue","docId":"api-reference/core/useRecoilValue"},{"type":"link","label":"useSetRecoilState()","href":"/docs/api-reference/core/useSetRecoilState","docId":"api-reference/core/useSetRecoilState"},{"type":"link","label":"useResetRecoilState()","href":"/docs/api-reference/core/useResetRecoilState","docId":"api-reference/core/useResetRecoilState"},{"type":"link","label":"useRecoilStateLoadable()","href":"/docs/api-reference/core/useRecoilStateLoadable","docId":"api-reference/core/useRecoilStateLoadable"},{"type":"link","label":"useRecoilValueLoadable()","href":"/docs/api-reference/core/useRecoilValueLoadable","docId":"api-reference/core/useRecoilValueLoadable"},{"type":"link","label":"useGetRecoilValueInfo()","href":"/docs/api-reference/core/useGetRecoilValueInfo","docId":"api-reference/core/useGetRecoilValueInfo"},{"type":"link","label":"useRecoilRefresher()","href":"/docs/api-reference/core/useRecoilRefresher","docId":"api-reference/core/useRecoilRefresher"},{"type":"link","label":"isRecoilValue()","href":"/docs/api-reference/core/isRecoilValue","docId":"api-reference/core/isRecoilValue"}]},{"type":"category","collapsed":true,"collapsible":true,"label":"Utils","items":[{"type":"link","label":"atomFamily()","href":"/docs/api-reference/utils/atomFamily","docId":"api-reference/utils/atomFamily"},{"type":"link","label":"selectorFamily()","href":"/docs/api-reference/utils/selectorFamily","docId":"api-reference/utils/selectorFamily"},{"type":"link","label":"constSelector()","href":"/docs/api-reference/utils/constSelector","docId":"api-reference/utils/constSelector"},{"type":"link","label":"errorSelector()","href":"/docs/api-reference/utils/errorSelector","docId":"api-reference/utils/errorSelector"},{"type":"link","label":"noWait()","href":"/docs/api-reference/utils/noWait","docId":"api-reference/utils/noWait"},{"type":"link","label":"waitForAll()","href":"/docs/api-reference/utils/waitForAll","docId":"api-reference/utils/waitForAll"},{"type":"link","label":"waitForAllSettled()","href":"/docs/api-reference/utils/waitForAllSettled","docId":"api-reference/utils/waitForAllSettled"},{"type":"link","label":"waitForNone()","href":"/docs/api-reference/utils/waitForNone","docId":"api-reference/utils/waitForNone"},{"type":"link","label":"waitForAny()","href":"/docs/api-reference/utils/waitForAny","docId":"api-reference/utils/waitForAny"}]},{"type":"link","label":"useRecoilTransaction()","href":"/docs/api-reference/core/useRecoilTransaction","docId":"api-reference/core/useRecoilTransaction"},{"type":"link","label":"useRecoilCallback()","href":"/docs/api-reference/core/useRecoilCallback","docId":"api-reference/core/useRecoilCallback"},{"type":"category","collapsed":true,"collapsible":true,"label":"Snapshots","items":[{"type":"link","label":"Snapshot","href":"/docs/api-reference/core/Snapshot","docId":"api-reference/core/Snapshot"},{"type":"link","label":"useRecoilTransactionObserver()","href":"/docs/api-reference/core/useRecoilTransactionObserver","docId":"api-reference/core/useRecoilTransactionObserver"},{"type":"link","label":"useRecoilSnapshot()","href":"/docs/api-reference/core/useRecoilSnapshot","docId":"api-reference/core/useRecoilSnapshot"},{"type":"link","label":"useGotoRecoilSnapshot()","href":"/docs/api-reference/core/useGotoRecoilSnapshot","docId":"api-reference/core/useGotoRecoilSnapshot"}]},{"type":"category","collapsed":true,"collapsible":true,"label":"Misc","items":[{"type":"link","label":"useRecoilStoreID()","href":"/docs/api-reference/core/useRecoilStoreID","docId":"api-reference/core/useRecoilStoreID"},{"type":"link","label":"useRecoilBridgeAcrossReactRoots()","href":"/docs/api-reference/core/useRecoilBridgeAcrossReactRoots","docId":"api-reference/core/useRecoilBridgeAcrossReactRoots"}]},{"type":"link","label":"Recoil Environment","href":"/docs/api-reference/core/RecoilEnv","docId":"api-reference/core/RecoilEnv"}]}],"recoil-sync":[{"type":"link","label":"Introduction","href":"/docs/recoil-sync/introduction","docId":"recoil-sync/introduction"},{"type":"link","label":"Syncing Atoms","href":"/docs/recoil-sync/sync-effect","docId":"recoil-sync/sync-effect"},{"type":"link","label":"Implementing a Store","href":"/docs/recoil-sync/implement-store","docId":"recoil-sync/implement-store"},{"type":"link","label":"URL Persistence","href":"/docs/recoil-sync/url-persistence","docId":"recoil-sync/url-persistence"},{"type":"category","collapsed":true,"collapsible":true,"label":"API Reference","items":[{"type":"link","label":"<RecoilSync>","href":"/docs/recoil-sync/api/RecoilSync","docId":"recoil-sync/api/RecoilSync"},{"type":"link","label":"syncEffect()","href":"/docs/recoil-sync/api/syncEffect","docId":"recoil-sync/api/syncEffect"},{"type":"category","collapsed":true,"collapsible":true,"label":"URL Persistence","items":[{"type":"link","label":"<RecoilURLSync>","href":"/docs/recoil-sync/api/RecoilURLSync","docId":"recoil-sync/api/RecoilURLSync"},{"type":"link","label":"urlSyncEffect()","href":"/docs/recoil-sync/api/urlSyncEffect","docId":"recoil-sync/api/urlSyncEffect"},{"type":"link","label":"<RecoilURLSyncJSON>","href":"/docs/recoil-sync/api/RecoilURLSyncJSON","docId":"recoil-sync/api/RecoilURLSyncJSON"},{"type":"link","label":"<RecoilURLSyncTransit>","href":"/docs/recoil-sync/api/RecoilURLSyncTransit","docId":"recoil-sync/api/RecoilURLSyncTransit"}]}]}],"refine":[{"type":"link","label":"Refine","href":"/docs/refine/Introduction","docId":"refine/Introduction"},{"type":"category","collapsed":true,"collapsible":true,"label":"API Reference","items":[{"type":"link","label":"Utilities","href":"/docs/refine/api/Utilities","docId":"refine/api/Utilities"},{"type":"link","label":"Checkers","href":"/docs/refine/api/Checkers","docId":"refine/api/Checkers"},{"type":"link","label":"Primitive Checkers","href":"/docs/refine/api/Primitive_Checkers","docId":"refine/api/Primitive_Checkers"},{"type":"link","label":"Collection Checkers","href":"/docs/refine/api/Collection_Checkers","docId":"refine/api/Collection_Checkers"},{"type":"link","label":"Advanced Checkers","href":"/docs/refine/api/Advanced_Checkers","docId":"refine/api/Advanced_Checkers"}]}],"recoil-relay":[{"type":"link","label":"Introduction","href":"/docs/recoil-relay/introduction","docId":"recoil-relay/introduction"},{"type":"link","label":"Relay Environment","href":"/docs/recoil-relay/environment","docId":"recoil-relay/environment"},{"type":"link","label":"GraphQL Queries","href":"/docs/recoil-relay/graphql-queries","docId":"recoil-relay/graphql-queries"},{"type":"link","label":"GraphQL Mutations","href":"/docs/recoil-relay/graphql-mutations","docId":"recoil-relay/graphql-mutations"},{"type":"link","label":"GraphQL Subscriptions","href":"/docs/recoil-relay/graphql-subscriptions","docId":"recoil-relay/graphql-subscriptions"},{"type":"link","label":"GraphQL Atom Effects","href":"/docs/recoil-relay/graphql-effects","docId":"recoil-relay/graphql-effects"},{"type":"category","collapsed":true,"collapsible":true,"label":"API Reference","items":[{"type":"link","label":"EnvironmentKey","href":"/docs/recoil-relay/api/EnvironmentKey","docId":"recoil-relay/api/EnvironmentKey"},{"type":"link","label":"<RecoilRelayEnvironment>","href":"/docs/recoil-relay/api/RecoilRelayEnvironment","docId":"recoil-relay/api/RecoilRelayEnvironment"},{"type":"link","label":"<RecoilRelayEnvironmentProvider>","href":"/docs/recoil-relay/api/RecoilRelayEnvironmentProvider","docId":"recoil-relay/api/RecoilRelayEnvironmentProvider"},{"type":"link","label":"graphQLSelector()","href":"/docs/recoil-relay/api/graphQLSelector","docId":"recoil-relay/api/graphQLSelector"},{"type":"link","label":"graphQLSelectorFamily()","href":"/docs/recoil-relay/api/graphQLSelectorFamily","docId":"recoil-relay/api/graphQLSelectorFamily"},{"type":"category","collapsed":true,"collapsible":true,"label":"Atom Effects","items":[{"type":"link","label":"graphQLQueryEffect()","href":"/docs/recoil-relay/api/graphQLQueryEffect","docId":"recoil-relay/api/graphQLQueryEffect"},{"type":"link","label":"graphQLSubscriptionEffect()","href":"/docs/recoil-relay/api/graphQLSubscriptionEffect","docId":"recoil-relay/api/graphQLSubscriptionEffect"},{"type":"link","label":"graphQLMutationEffect()","href":"/docs/recoil-relay/api/graphQLMutationEffect","docId":"recoil-relay/api/graphQLMutationEffect"}]}]}]},"docs":{"api-reference/core/atom":{"id":"api-reference/core/atom","title":"atom(options)","description":"An atom represents state in Recoil.  The atom() function returns a writeable RecoilState object.","sidebar":"docs"},"api-reference/core/isRecoilValue":{"id":"api-reference/core/isRecoilValue","title":"isRecoilValue(value)","description":"Returns true if value is either an atom or selector and false otherwise.","sidebar":"docs"},"api-reference/core/Loadable":{"id":"api-reference/core/Loadable","title":"class Loadable","description":"A Loadable object represents the current state of a Recoil atom or selector.  This state may either have a value available, may be in an error state, or may still be pending asynchronous resolution.  A Loadable has the following interface:","sidebar":"docs"},"api-reference/core/RecoilEnv":{"id":"api-reference/core/RecoilEnv","title":"Recoil Environment","description":"RecoilEnv","sidebar":"docs"},"api-reference/core/RecoilRoot":{"id":"api-reference/core/RecoilRoot","title":"<RecoilRoot>","description":"Provides the context in which atoms have values. Must be an ancestor of any component that uses any Recoil hooks.","sidebar":"docs"},"api-reference/core/selector":{"id":"api-reference/core/selector","title":"selector(options)","description":"Selectors represent a function, or derived state in Recoil.  You can think of them as similar to an \\"idempotent\\" or \\"pure function\\" without side-effects that always returns the same value for a given set of dependency values.  If only a get function is provided, the selector is read-only and returns a RecoilValueReadOnly object.  If a set is also provided, it returns a writeable RecoilState object.","sidebar":"docs"},"api-reference/core/Snapshot":{"id":"api-reference/core/Snapshot","title":"class Snapshot","description":"A Snapshot object represents an immutable snapshot of the state of Recoil atoms.  It is intended to standardize the API for observing, inspecting, and managing global Recoil state.  It is mostly useful for dev tools, global state synchronization, history navigation, etc.","sidebar":"docs"},"api-reference/core/useGetRecoilValueInfo":{"id":"api-reference/core/useGetRecoilValueInfo","title":"useGetRecoilValueInfo_UNSTABLE()","description":"This hook allows a component to \\"peek\\" at the current state, value, and other information about an atom or selector.  This is similar to the getInfo_UNSTABLE() method in Snapshot and atom effects","sidebar":"docs"},"api-reference/core/useGotoRecoilSnapshot":{"id":"api-reference/core/useGotoRecoilSnapshot","title":"useGotoRecoilSnapshot(snapshot)","description":"This hook returns a callback which takes a Snapshot as a parameter and will update the current `` state to match this atom state.","sidebar":"docs"},"api-reference/core/useRecoilBridgeAcrossReactRoots":{"id":"api-reference/core/useRecoilBridgeAcrossReactRoots","title":"useRecoilBridgeAcrossReactRoots()","description":"A hook to help with bridging Recoil state with a nested React root and renderer.","sidebar":"docs"},"api-reference/core/useRecoilCallback":{"id":"api-reference/core/useRecoilCallback","title":"useRecoilCallback(callback, deps)","description":"This hook is similar to useCallback(), but will also provide an API for your callbacks to work with Recoil state.  This hook can be used to construct a callback that has access to a read-only Snapshot of Recoil state and the ability to asynchronously update current Recoil state.","sidebar":"docs"},"api-reference/core/useRecoilRefresher":{"id":"api-reference/core/useRecoilRefresher","title":"useRecoilRefresher_UNSTABLE(state)","description":"The useRecoilRefresher_UNSTABLE() hook returns a callback which can be called with a selector to clear any caches associated with it.  If a selector makes any async requests this would cause it to re-evaluate and issue a new request.  This is useful, for example, if you wish to refresh with newer data or re-try after an error.  (See Asynchronous Data Queries Guide)","sidebar":"docs"},"api-reference/core/useRecoilSnapshot":{"id":"api-reference/core/useRecoilSnapshot","title":"useRecoilSnapshot()","description":"This hook synchronously returns a Snapshot object during rendering and subscribes the calling component for all Recoil state changes.  You may want to use this hook for debug tools, or for server-side rendering where you need to synchronously have the state during the initial render.","sidebar":"docs"},"api-reference/core/useRecoilState":{"id":"api-reference/core/useRecoilState","title":"useRecoilState(state)","description":"Returns a tuple where the first element is the value of state and the second element is a setter function that will update the value of the given state when called.","sidebar":"docs"},"api-reference/core/useRecoilStateLoadable":{"id":"api-reference/core/useRecoilStateLoadable","title":"useRecoilStateLoadable(state)","description":"This hook is intended to be used for reading the value of asynchronous selectors. This hook will implicitly subscribe the component to the given state.","sidebar":"docs"},"api-reference/core/useRecoilStoreID":{"id":"api-reference/core/useRecoilStoreID","title":"useRecoilStoreID()","description":"Provides a StoreID associated with the currently active ``.","sidebar":"docs"},"api-reference/core/useRecoilTransaction":{"id":"api-reference/core/useRecoilTransaction","title":"useRecoilTransaction_UNSTABLE(callback, deps)","description":"Create a transaction callback which can be used to atomically update multiple atoms in a safe, easy, and efficient way.  Provide a callback for the transaction as a pure function which can get() or set() multiple atoms.  A transaction is similar to the \\"updater\\" form of setting Recoil state, but can operate over multiple atoms.  Writes are visible to subsequent reads from within the same transaction.","sidebar":"docs"},"api-reference/core/useRecoilTransactionObserver":{"id":"api-reference/core/useRecoilTransactionObserver","title":"useRecoilTransactionObserver_UNSTABLE(callback)","description":"NOTE: Please consider this API as unstable","sidebar":"docs"},"api-reference/core/useRecoilValue":{"id":"api-reference/core/useRecoilValue","title":"useRecoilValue(state)","description":"Returns the value of the given Recoil state.","sidebar":"docs"},"api-reference/core/useRecoilValueLoadable":{"id":"api-reference/core/useRecoilValueLoadable","title":"useRecoilValueLoadable(state)","description":"This hook is intended to be used for reading the value of asynchronous selectors. This hook will subscribe the component to the given state.","sidebar":"docs"},"api-reference/core/useResetRecoilState":{"id":"api-reference/core/useResetRecoilState","title":"useResetRecoilState(state)","description":"Returns a function that will reset the value of the given state to its default value.","sidebar":"docs"},"api-reference/core/useSetRecoilState":{"id":"api-reference/core/useSetRecoilState","title":"useSetRecoilState(state)","description":"Returns a setter function for updating the value of writeable Recoil state.","sidebar":"docs"},"api-reference/utils/atomFamily":{"id":"api-reference/utils/atomFamily","title":"atomFamily(options)","description":"Returns a function that returns a writeable RecoilState atom.","sidebar":"docs"},"api-reference/utils/constSelector":{"id":"api-reference/utils/constSelector","title":"constSelector(constant)","description":"A selector which always provides a constant value.","sidebar":"docs"},"api-reference/utils/errorSelector":{"id":"api-reference/utils/errorSelector","title":"errorSelector(message)","description":"A selector which always throws the provided error","sidebar":"docs"},"api-reference/utils/noWait":{"id":"api-reference/utils/noWait","title":"noWait(state)","description":"A selector helper that will return a Loadable for the current state of the provided atom or selector.","sidebar":"docs"},"api-reference/utils/selectorFamily":{"id":"api-reference/utils/selectorFamily","title":"selectorFamily(options)","description":"Returns a function that returns a read-only RecoilValueReadOnly or writeable RecoilState selector.","sidebar":"docs"},"api-reference/utils/waitForAll":{"id":"api-reference/utils/waitForAll","title":"waitForAll(dependencies)","description":"A concurrency helper which allows us to concurrently evaluate multiple asynchronous dependencies.","sidebar":"docs"},"api-reference/utils/waitForAllSettled":{"id":"api-reference/utils/waitForAllSettled","title":"waitForAllSettled(dependencies)","description":"A concurrency helper that returns a set of Loadables for the current state of the requested dependencies.  It waits until all of the dependencies are either in a value state, or an error state.","sidebar":"docs"},"api-reference/utils/waitForAny":{"id":"api-reference/utils/waitForAny","title":"waitForAny(dependencies)","description":"A concurrency helper that returns a set of Loadables for the current state of the requested dependencies.  It waits until at least one of the dependencies is available.","sidebar":"docs"},"api-reference/utils/waitForNone":{"id":"api-reference/utils/waitForNone","title":"waitForNone(dependencies)","description":"A concurrency helper that returns a set of Loadables for the current state of the requested dependencies.","sidebar":"docs"},"basic-tutorial/atoms":{"id":"basic-tutorial/atoms","title":"Atoms","description":"Atoms contain the source of truth for our application state. In our todo-list, the source of truth will be an array of objects, with each object representing a todo item.","sidebar":"docs"},"basic-tutorial/demo":{"id":"basic-tutorial/demo","title":"Demo (Todo List)","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"basic-tutorial/intro":{"id":"basic-tutorial/intro","title":"Tutorial Intro","description":"This section assumes you have installed Recoil and React. See the Getting Started page for how to get started with Recoil and React from scratch. Components in the following sections are assumed to have a `` in the parent tree.","sidebar":"docs"},"basic-tutorial/performance":{"id":"basic-tutorial/performance","title":"Bonus: Performance","description":"Our existing implementation is perfectly valid, but there are some important performance implications to consider as our app evolves from being a small toy project to a million-line corporate program."},"basic-tutorial/selectors":{"id":"basic-tutorial/selectors","title":"Selectors","description":"A selector represents a piece of derived state. You can think of derived state as the output of passing state to a pure function that derives a new value from the said state.","sidebar":"docs"},"guides/asynchronous-data-queries":{"id":"guides/asynchronous-data-queries","title":"Asynchronous Data Queries","description":"Recoil provides a way to map state and derived state to React components via a data-flow graph. What\'s really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector get callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data.","sidebar":"docs"},"guides/atom-effects":{"id":"guides/atom-effects","title":"Atom Effects","description":"Atom effects are an API for managing side-effects and synchronizing or initializing Recoil atoms.  They have a variety of useful applications such as state persistence, state synchronization, managing history, logging, &c.  They are similar to React effects, but are defined as part of the atom definition, so each atom can specify and compose their own policies.  Also check out the recoil-sync library for some implementations of syncing (such as URL persistence) or more advanced use cases.","sidebar":"docs"},"guides/code-splitting":{"id":"guides/code-splitting","title":"Code Splitting","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"guides/dev-tools":{"id":"guides/dev-tools","title":"Development Tools","description":"Recoil has functionality to allow you to observe and update state changes.","sidebar":"docs"},"guides/migrating/from-mobx":{"id":"guides/migrating/from-mobx","title":"From MobX","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"guides/migrating/from-react-state":{"id":"guides/migrating/from-react-state","title":"From React State","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"guides/migrating/from-redux":{"id":"guides/migrating/from-redux","title":"From Redux","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"guides/testing":{"id":"guides/testing","title":"Testing","description":"Testing Recoil state inside of a React component","sidebar":"docs"},"guides/transitions":{"id":"guides/transitions","title":"React 18 Transitions","description":"React 18 offers a new hook useTransition() for transitioning to a new state while having control over what to render before the new state is ready. Recoil should be compatible with this approach and provides a consistent view with React state. However, React 18 may fallback from concurrent updates and does not yet officially support initiating transitions based on state changes to external stores. This is something the React team is looking into supporting, but until then we have added experimental support for this through the following hooks; other hooks should already fully support transitions, so only these variants are necessary. This API is considered experimental because there may be use cases we haven\u2019t found which are not handled.","sidebar":"docs"},"introduction/core-concepts":{"id":"introduction/core-concepts","title":"Core Concepts","description":"Overview","sidebar":"docs"},"introduction/getting-started":{"id":"introduction/getting-started","title":"Getting Started","description":"Create React App","sidebar":"docs"},"introduction/installation":{"id":"introduction/installation","title":"Installation","description":"NPM","sidebar":"docs"},"introduction/motivation":{"id":"introduction/motivation","title":"Motivation","description":"For reasons of compatibility and simplicity, it\'s best to use React\'s built-in state management capabilities rather than external global state. But React has certain limitations:","sidebar":"docs"},"mdx":{"id":"mdx","title":"Powered by MDX","description":"You can write JSX and use React components within your Markdown thanks to MDX."},"recoil-relay/api/EnvironmentKey":{"id":"recoil-relay/api/EnvironmentKey","title":"EnvironmentKey","description":"An EnvironmentKey is class that can be used to match up a Relay Environment registered with ` in your ` with a GraphQL selector or atom effect that uses it to query.","sidebar":"recoil-relay"},"recoil-relay/api/graphQLMutationEffect":{"id":"recoil-relay/api/graphQLMutationEffect","title":"graphQLMutationEffect()","description":"The underlying atom effect for causing a local update to an atom to iniate commiting a GraphQL mutation to the server.","sidebar":"recoil-relay"},"recoil-relay/api/graphQLQueryEffect":{"id":"recoil-relay/api/graphQLQueryEffect","title":"graphQLQueryEffect()","description":"The underlying atom effect for syncing a Recoil atom with a GraphQL query.  It initializes an atom based on the results of a GraphQL query and subscribes to local mutations or updates.","sidebar":"recoil-relay"},"recoil-relay/api/graphQLSelector":{"id":"recoil-relay/api/graphQLSelector","title":"graphQLSelector()","description":"graphQLSelector() creates a Recoil selector which syncs with the provided Relay environment and GraphQL query or subscription.  The selector will automatically update with any deferred data, live queries, or if any local commits or updates are performed which mutate that part of the graph.  The selector acts like a local cache with the server as the source of truth.  It is writable and can be configured to commit mutations to the server when updated as a write-through cache.","sidebar":"recoil-relay"},"recoil-relay/api/graphQLSelectorFamily":{"id":"recoil-relay/api/graphQLSelectorFamily","title":"graphQLSelectorFamily()","description":"graphQLSelectorFamily() is similar to graphQLSelector() except that it returns a function which accepts a parameter and returns a selector for that parameter.  This basically allows us to pass parameters to the query from the calling component based on props or other state.","sidebar":"recoil-relay"},"recoil-relay/api/graphQLSubscriptionEffect":{"id":"recoil-relay/api/graphQLSubscriptionEffect","title":"graphQLSubscriptionEffect()","description":"The underlying atom effect for syncing a Recoil atom with a GraphQL subscription.  It initializes an atom based on the results of a GraphQL subscription and subscribes to updates from the server.","sidebar":"recoil-relay"},"recoil-relay/api/RecoilRelayEnvironment":{"id":"recoil-relay/api/RecoilRelayEnvironment","title":"<RecoilRelayEnvironment>","description":"A component that registers a Relay Environment to be used by GraphQL selectors or atom effects referenced by its child components with matching EnvironmentKey.","sidebar":"recoil-relay"},"recoil-relay/api/RecoilRelayEnvironmentProvider":{"id":"recoil-relay/api/RecoilRelayEnvironmentProvider","title":"<RecoilRelayEnvironmentProvider>","description":"The ` component enables you to use a Relay Environment with Recoil GraphQL selectors or atom effects in its child components.  The  component enables you to use a Relay Environment with Relay hooks in its child components.  ` is simply a convenience component which combines these two.","sidebar":"recoil-relay"},"recoil-relay/environment":{"id":"recoil-relay/environment","title":"Relay Environment","description":"To use GraphQL with the recoil-relay library you\'ll need to reference your Relay environment(s).  Each GraphQL selector or effect requires an environment option which can either reference a Relay Environment directly or be an EnvironmentKey that matches up with a `` component that registered a Relay environment.","sidebar":"recoil-relay"},"recoil-relay/graphql-effects":{"id":"recoil-relay/graphql-effects","title":"GraphQL Atom Effects","description":"The underlying GraphQL synchronization support is provided via atom effects.  While GraphQL selectors are provided as a convenience to make them easier to use, you could also apply these effects directly to atoms.  To use these, you\'ll need to either reference or register your Relay environment.","sidebar":"recoil-relay"},"recoil-relay/graphql-mutations":{"id":"recoil-relay/graphql-mutations","title":"GraphQL Mutations","description":"GraphQL Mutations","sidebar":"recoil-relay"},"recoil-relay/graphql-queries":{"id":"recoil-relay/graphql-queries","title":"GraphQL Queries","description":"GraphQL queries can be done using graphQLSelector() and graphQLSelectorFamily().  (The underlying support is provided via atom effects).  But first, make sure to setup your Relay environment.","sidebar":"recoil-relay"},"recoil-relay/graphql-subscriptions":{"id":"recoil-relay/graphql-subscriptions","title":"GraphQL Subscriptions","description":"While GraphQL queries will subscribe to changes from locally issued mutations or live updates, you may also want to subscribe to updates that are pushed by the server.  In this situation you can use a GraphQL _subscription_ instead of a GraphQL _query_.  GraphQL subscriptions require a different implementation on the server to support initiating remote updates.","sidebar":"recoil-relay"},"recoil-relay/introduction":{"id":"recoil-relay/introduction","title":"Recoil and GraphQL with Relay","description":"The recoil-relay NPM library helps Recoil perform type safe and efficient queries using GraphQL with the Relay library.  It provides selectors which can easily query with GraphQL.  The queries are synced with the Recoil data-flow graph so downstream selectors can derive state from them, they can depend on upstream Recoil state, and they are automatically subscribed to any changes in the graph from Relay.  Everything stays in sync automatically.","sidebar":"recoil-relay"},"recoil-sync/api/RecoilSync":{"id":"recoil-sync/api/RecoilSync","title":"<RecoilSync> - Recoil Sync Store","description":"Component from the Recoil Sync library to define an external store for atoms to sync with using the syncEffect() atom effect.","sidebar":"recoil-sync"},"recoil-sync/api/RecoilURLSync":{"id":"recoil-sync/api/RecoilURLSync","title":"<RecoilURLSync>","description":"A component from the Recoil Sync library to sync atoms using the syncEffect() or urlSyncEffect() atom effects with the browser URL.","sidebar":"recoil-sync"},"recoil-sync/api/RecoilURLSyncJSON":{"id":"recoil-sync/api/RecoilURLSyncJSON","title":"<RecoilURLSyncJSON>","description":"A component from the Recoil Sync library to sync atoms using the syncEffect() or urlSyncEffect() atom effects with the browser URL.","sidebar":"recoil-sync"},"recoil-sync/api/RecoilURLSyncTransit":{"id":"recoil-sync/api/RecoilURLSyncTransit","title":"<RecoilURLSyncTransit>","description":"A component from the Recoil Sync library to sync atoms using the syncEffect() or urlSyncEffect() atom effects with the browser URL.","sidebar":"recoil-sync"},"recoil-sync/api/syncEffect":{"id":"recoil-sync/api/syncEffect","title":"syncEffect(...)","description":"A function to get an atom effect for the recoil-sync library to synchronize an atom with external state defined with the `` component.","sidebar":"recoil-sync"},"recoil-sync/api/urlSyncEffect":{"id":"recoil-sync/api/urlSyncEffect","title":"urlSyncEffect(...)","description":"An optional effect that may be used instead of syncEffect() for URL Persistence in order to specify additional options, such as if state changes should replace the URL or push a new entry in the browser history stack.","sidebar":"recoil-sync"},"recoil-sync/implement-store":{"id":"recoil-sync/implement-store","title":"Implementing a Store","description":"While the library comes with some built-in stores, you can implement your own using `.   Specify an optional storeKey` to identify and match up which atoms should sync with which store.  Then, specify the following optional callbacks to define the behavior for your store:","sidebar":"recoil-sync"},"recoil-sync/introduction":{"id":"recoil-sync/introduction","title":"Recoil Sync Library","description":"The recoil-sync NPM package provides an add-on library to help synchronize Recoil state with external systems.  Simple asynchronous data queries can be implemented via selectors or useEffect(), or atom effects can be used for bi-directional syncing of individual atoms.  The recoil-sync add-on package provides some additional functionality:","sidebar":"recoil-sync"},"recoil-sync/sync-effect":{"id":"recoil-sync/sync-effect","title":"Sync Atom Effect - syncEffect()","description":"syncEffect() is an atom effect is used to tag atoms that should be synchronized and have them initialize their value with the external store.  The only required option is refine for input validation.  The itemKey option allows you to specify a key for this particular atom with the external store.  If not specified, it defaults to the atom\'s own key.  A storeKey can also be provided to match up which external store to sync with, if you have more than one.  There are additional options, such as read and write for more advanced cases.","sidebar":"recoil-sync"},"recoil-sync/url-persistence":{"id":"recoil-sync/url-persistence","title":"URL Persistence","description":"One of the built-in external store syncing mechanisms provided with the recoil-sync package is URL persistence.  This enables users to easily initialize atoms based on the URL, update the URL when atoms mutate, and subscribe to URL changes (such as the back button).  Atom state changes can be configured to either replace the current URL or push a new entry in the browser history stack.","sidebar":"recoil-sync"},"refine/api/Advanced_Checkers":{"id":"refine/api/Advanced_Checkers","title":"Advanced Refine Checkers","description":"In addition to collections and primitives, more complex types can be modeled using the following combinator checkers.","sidebar":"refine"},"refine/api/Checkers":{"id":"refine/api/Checkers","title":"Refine Checkers","description":"The core of Refine is the Checker type. Checkers are essentially just functions which take in a mixed (for Flow) or unknown (for TypeScript) value and return  a CheckResult...","sidebar":"refine"},"refine/api/Collection_Checkers":{"id":"refine/api/Collection_Checkers","title":"Refine Collection Checkers","description":"Collection checkers can be combined with primitive checkers to refine more complex values.","sidebar":"refine"},"refine/api/Primitive_Checkers":{"id":"refine/api/Primitive_Checkers","title":"Refine Primitive Checkers","description":"The starting place for building a Refine checker is with the primitive combinators.","sidebar":"refine"},"refine/api/Utilities":{"id":"refine/api/Utilities","title":"Refine Utilities","description":"In addition to the core Checker combinators provided by Refine, the library also exposes some utility functions to help with things like JSON parsing and assertion functions.","sidebar":"refine"},"refine/Introduction":{"id":"refine/Introduction","title":"Refine","description":"Refine is a type-refinement and validator combinator library for mixed / unknown values in Flow or TypeScript.","sidebar":"refine"}}}')}}]);