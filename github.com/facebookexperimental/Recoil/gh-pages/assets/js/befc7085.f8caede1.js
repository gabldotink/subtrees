"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[9569],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,f=u["".concat(s,".").concat(m)]||u[m]||p[m]||a;return n?r.createElement(f,i(i({ref:t},d),{},{components:n})):r.createElement(f,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5256:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},assets:function(){return d},toc:function(){return p},default:function(){return m}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],l={title:"Recoil 0.0.8"},s=void 0,c={permalink:"/blog/2020/05/30/0.0.8-released",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2020-05-30-0.0.8-released.md",source:"@site/blog/2020-05-30-0.0.8-released.md",title:"Recoil 0.0.8",description:"Today we are releasing Recoil 0.0.8. It contains bug fixes and new features. Thanks so much to everyone who contributed to this release! It's been amazing to see so many people contribute.",date:"2020-05-30T00:00:00.000Z",formattedDate:"May 30, 2020",tags:[],readingTime:3.075,truncated:!0,authors:[],prevItem:{title:"Recoil 0.0.10",permalink:"/blog/2020/06/18/0.0.10-released"}},d={authorsImageUrls:[]},p=[{value:"Bug Fixes",id:"bug-fixes",children:[],level:2},{value:"Features",id:"features",children:[{value:"TypeScript support",id:"typescript-support",children:[],level:3},{value:"<code>atomFamily</code> and <code>selectorFamily</code>",id:"atomfamily-and-selectorfamily",children:[],level:3},{value:"Concurrency helpers",id:"concurrency-helpers",children:[],level:3},{value:"<code>constSelector</code> and <code>errorSelector</code>",id:"constselector-and-errorselector",children:[],level:3},{value:"readOnlySelector",id:"readonlyselector",children:[],level:3}],level:2},{value:"What&#39;s Next",id:"whats-next",children:[],level:2}],u={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Today we are releasing Recoil 0.0.8. It contains bug fixes and new features. Thanks so much to everyone who contributed to this release! It's been amazing to see so many people contribute."),(0,a.kt)("h2",{id:"bug-fixes"},"Bug Fixes"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Fixed a bug where atoms that stored self-referential structures would cause an infinite loop. (@n3tr in #153)"),(0,a.kt)("li",{parentName:"ul"},"Fixed bugs affecting Server-Side Rendering. (@sbaudray in #53)"),(0,a.kt)("li",{parentName:"ul"},"Fixed build system and repository syncing problems. Many people contributed to this, especially @mondaychen and including\n@claudiopro, @dustinsoftware, @jacques-blom, @jaredpalmer, @kentcdodds, @leushkin, and @tony-go. It remains to get Jest and Flow to behave the same between internal and OSS.")),(0,a.kt)("h2",{id:"features"},"Features"),(0,a.kt)("h3",{id:"typescript-support"},"TypeScript support"),(0,a.kt)("p",null,"TypeScript definitions are now available via the ",(0,a.kt)("inlineCode",{parentName:"p"},"DefinitelyTyped")," repository."),(0,a.kt)("h3",{id:"atomfamily-and-selectorfamily"},(0,a.kt)("inlineCode",{parentName:"h3"},"atomFamily")," and ",(0,a.kt)("inlineCode",{parentName:"h3"},"selectorFamily")),(0,a.kt)("p",null,"These utilities help you create collections of related atoms or selectors, one for each value of some parameter. Instaed of manually creating a memoized function that returns an atom or selector, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"atomFamily")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"selectorFamily"),". In the future, these utilities will also help with memory management."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"atomFamily")," function returns a function from some parameter to an atom, creating a new atom for each value of the parameter that is passed in. For example, suppose you wanted to store a set of coordinates ",(0,a.kt)("inlineCode",{parentName:"p"},"{x: number, y: number}")," for every member of a collection identified by some ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),". Then you could write:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const coordinatesForID = atomFamily<{x: number, y: number}, ID>({\n    key: 'coordinatesForID',\n    default: {x: 0, y: 0},\n});\n")),(0,a.kt)("p",null,"and then access that state as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyComponent({id}) {\n    const [coordinates, setCoordinates] = useRecoilState(\n        coordinatesForID(id)\n    );\n    ...\n}\n")),(0,a.kt)("p",null,"Each ",(0,a.kt)("inlineCode",{parentName:"p"},"ID")," passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"coordinatesForID")," will get its own independent atom containing the coordinates. Each of these atoms has its own subscriptions, so a component that uses the state for a single ID will only be subscribed to changes to that one ID."),(0,a.kt)("p",null,"Similarly, ",(0,a.kt)("inlineCode",{parentName:"p"},"selectorFamily")," lets you create a different selector for each value of some parameter. For example, suppose you wanted to take each of those coordinates and rotate them by 180 degrees:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const rotatedCoordinatesForID = selectorFamily<{x: number, y: number}, ID>({\n    key: 'rotatedCoordinatesForID',\n    get: id => ({get}) => {\n        const coordinates = get(coordinatesForID(id));\n        return {\n            x: -coordinates.x,\n            y: -coordinates.y,\n        };\n    }\n});\n")),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"get")," property of a selector family is a function that takes the parameter (in this case ID) and returns a function with a signature identical to the ",(0,a.kt)("inlineCode",{parentName:"p"},"get")," property of a single selector. In general, this is how all of the options for atom families and selector families work."),(0,a.kt)("h3",{id:"concurrency-helpers"},"Concurrency helpers"),(0,a.kt)("p",null,"We've introduced selector families for controlling concurrency in async selectors:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"waitForAll"),": requests all dependencies in parallel and waits for all of them to become available."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"waitForAny"),": requests all dependencies in parallel and waits for any one of them to become available."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"waitForNone"),": requests all dependencies in parallel but doesn't wait for any of them."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"noWait")," requests a single dependency but doesn't wait for it to become available.")),(0,a.kt)("p",null,"These can be used to retireve multiple dependencies in parallel and to write logic conditional on the status of an upstream dependency. For example, you can write a selector that conditionally provides a default value while an async process is in flight instead of propagating that loading state down to components."),(0,a.kt)("h3",{id:"constselector-and-errorselector"},(0,a.kt)("inlineCode",{parentName:"h3"},"constSelector")," and ",(0,a.kt)("inlineCode",{parentName:"h3"},"errorSelector")),(0,a.kt)("p",null,"These selector families simply return a constant value or always throw a given error, respectively."),(0,a.kt)("h3",{id:"readonlyselector"},"readOnlySelector"),(0,a.kt)("p",null,"This simply wraps a read-write ",(0,a.kt)("inlineCode",{parentName:"p"},"RecoilState")," in a read-only interface."),(0,a.kt)("h2",{id:"whats-next"},"What's Next"),(0,a.kt)("p",null,"We're working on improvements to the observation and persistence APIs, improved speed and memory management, and support for Concurrent Mode. Thanks so much for trying Recoil, we hope you'll stick around and see what it becomes!"))}m.isMDXComponent=!0}}]);