"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[4470],{3905:function(e,n,r){r.d(n,{Zo:function(){return c},kt:function(){return f}});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function u(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},s=Object.keys(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=t.createContext({}),l=function(e){var n=t.useContext(i),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},c=function(e){var n=l(e.components);return t.createElement(i.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),p=l(r),f=a,h=p["".concat(i,".").concat(f)]||p[f]||d[f]||s;return r?t.createElement(h,o(o({ref:n},c),{},{components:r})):t.createElement(h,o({ref:n},c))}));function f(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=p;var u={};for(var i in n)hasOwnProperty.call(n,i)&&(u[i]=n[i]);u.originalType=e,u.mdxType="string"==typeof e?e:a,o[1]=u;for(var l=2;l<s;l++)o[l]=r[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5590:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return u},contentTitle:function(){return i},metadata:function(){return l},toc:function(){return c},default:function(){return p}});var t=r(7462),a=r(3366),s=(r(7294),r(3905)),o=["components"],u={title:"Asynchronous Data Queries",sidebar_label:"Asynchronous Data Queries"},i=void 0,l={unversionedId:"guides/asynchronous-data-queries",id:"guides/asynchronous-data-queries",title:"Asynchronous Data Queries",description:"Recoil provides a way to map state and derived state to React components via a data-flow graph. What's really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector get callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data.",source:"@site/docs/guides/asynchronous-data-queries.md",sourceDirName:"guides",slug:"/guides/asynchronous-data-queries",permalink:"/docs/guides/asynchronous-data-queries",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/guides/asynchronous-data-queries.md",tags:[],version:"current",frontMatter:{title:"Asynchronous Data Queries",sidebar_label:"Asynchronous Data Queries"},sidebar:"docs",previous:{title:"Selectors",permalink:"/docs/basic-tutorial/selectors"},next:{title:"Atom Effects",permalink:"/docs/guides/atom-effects"}},c=[{value:"Synchronous Example",id:"synchronous-example",children:[],level:2},{value:"Asynchronous Example",id:"asynchronous-example",children:[],level:2},{value:"Error Handling",id:"error-handling",children:[],level:2},{value:"Queries with Parameters",id:"queries-with-parameters",children:[],level:2},{value:"Data-Flow Graph",id:"data-flow-graph",children:[],level:2},{value:"Concurrent Requests",id:"concurrent-requests",children:[],level:2},{value:"Pre-Fetching",id:"pre-fetching",children:[],level:2},{value:"Query Default Atom Values",id:"query-default-atom-values",children:[],level:2},{value:"Async Queries Without React Suspense",id:"async-queries-without-react-suspense",children:[],level:2},{value:"Query Refresh",id:"query-refresh",children:[{value:"<code>useRecoilRefresher()</code>",id:"userecoilrefresher",children:[],level:3},{value:"Use a Request ID",id:"use-a-request-id",children:[],level:3},{value:"Use an Atom",id:"use-an-atom",children:[],level:3},{value:"Retry query from error message",id:"retry-query-from-error-message",children:[],level:3}],level:2}],d={toc:c};function p(e){var n=e.components,r=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,t.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recoil provides a way to map state and derived state to React components via a data-flow graph. What's really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector ",(0,s.kt)("inlineCode",{parentName:"p"},"get")," callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data."),(0,s.kt)("p",null,'Selectors can be used as one way to incorporate asynchronous data into the Recoil data-flow graph.  Please keep in mind that selectors represent "idempotent" functions: For a given set of inputs they should always produce the same results (at least for the lifetime of the application).  This is important as selector evaluations may be cached, restarted, or executed multiple times.  Because of this, selectors are generally a good way to model read-only DB queries.  For mutable data you can use a ',(0,s.kt)("a",{parentName:"p",href:"#query-refresh"},"Query Refresh"),".  Or to synchronize mutable state, persist state, or for other side-effects, consider the ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},(0,s.kt)("strong",{parentName:"a"},"Atom Effects"))," API or the ",(0,s.kt)("a",{parentName:"p",href:"/docs/recoil-sync/introduction"},(0,s.kt)("strong",{parentName:"a"},"Recoil Sync Library")),"."),(0,s.kt)("h2",{id:"synchronous-example"},"Synchronous Example"),(0,s.kt)("p",null,"For example, here is a simple synchronous ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/atom"},"atom")," and ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/selector"},"selector")," to get a user name:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: 1,\n});\n\nconst currentUserNameState = selector({\n  key: 'CurrentUserName',\n  get: ({get}) => {\n    return tableOfUsers[get(currentUserIDState)].name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameState);\n  return <div>{userName}</div>;\n}\n\nfunction MyApp() {\n  return (\n    <RecoilRoot>\n      <CurrentUserInfo />\n    </RecoilRoot>\n  );\n}\n")),(0,s.kt)("h2",{id:"asynchronous-example"},"Asynchronous Example"),(0,s.kt)("p",null,"If the user names were stored in some database we need to query, all we need to do is return a ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise")," or use an ",(0,s.kt)("inlineCode",{parentName:"p"},"async")," function. If any dependencies change, the selector will be re-evaluated and execute a new query. The results are cached, so the query will only execute once per unique input."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const currentUserNameQuery = selector({\n  key: 'CurrentUserName',\n  get: async ({get}) => {\n    const response = await myDBQuery({\n      userID: get(currentUserIDState),\n    });\n    return response.name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameQuery);\n  return <div>{userName}</div>;\n}\n")),(0,s.kt)("p",null,"The interface of the selector is the same, so the component using this selector doesn't need to care if it was backed with synchronous atom state, derived selector state, or asynchronous queries!"),(0,s.kt)("p",null,"But, since React render functions are synchronous, what will it render before the promise resolves? Recoil is designed to work with ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/concurrent-mode-suspense.html"},"React Suspense")," to handle pending data. Wrapping your component with a Suspense boundary will catch any descendants that are still pending and render a fallback UI:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"function MyApp() {\n  return (\n    <RecoilRoot>\n      <React.Suspense fallback={<div>Loading...</div>}>\n        <CurrentUserInfo />\n      </React.Suspense>\n    </RecoilRoot>\n  );\n}\n")),(0,s.kt)("h2",{id:"error-handling"},"Error Handling"),(0,s.kt)("p",null,"But what if the request has an error? Recoil selectors can also throw errors which will then be thrown if a component tries to use that value. This can be caught with a React ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/error-boundaries.html"},(0,s.kt)("inlineCode",{parentName:"a"},"<ErrorBoundary>")),". For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const currentUserNameQuery = selector({\n  key: 'CurrentUserName',\n  get: async ({get}) => {\n    const response = await myDBQuery({\n      userID: get(currentUserIDState),\n    });\n    if (response.error) {\n      throw response.error;\n    }\n    return response.name;\n  },\n});\n\nfunction CurrentUserInfo() {\n  const userName = useRecoilValue(currentUserNameQuery);\n  return <div>{userName}</div>;\n}\n\nfunction MyApp() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Loading...</div>}>\n          <CurrentUserInfo />\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),(0,s.kt)("h2",{id:"queries-with-parameters"},"Queries with Parameters"),(0,s.kt)("p",null,"Sometimes you want to be able to query based on parameters that aren't just based on derived state. For example, you may want to query based on the component props. You can do that using the ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/selectorFamily"},(0,s.kt)("strong",{parentName:"a"},(0,s.kt)("inlineCode",{parentName:"strong"},"selectorFamily()")))," helper:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userNameQuery = selectorFamily({\n  key: 'UserName',\n  get: userID => async () => {\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response.name;\n  },\n});\n\nfunction UserInfo({userID}) {\n  const userName = useRecoilValue(userNameQuery(userID));\n  return <div>{userName}</div>;\n}\n\nfunction MyApp() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Loading...</div>}>\n          <UserInfo userID={1}/>\n          <UserInfo userID={2}/>\n          <UserInfo userID={3}/>\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),(0,s.kt)("h2",{id:"data-flow-graph"},"Data-Flow Graph"),(0,s.kt)("p",null,"Remember, by modeling queries as selectors, we can build a data-flow graph mixing state, derived state, and queries!  This graph will automatically update and re-render React components as state is updated."),(0,s.kt)("p",null,"The following example will render the current user's name and a list of their friends.  If a friend's name is clicked on, they will become the current user and the name and list will be automatically updated."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: null,\n});\n\nconst userInfoQuery = selectorFamily({\n  key: 'UserInfoQuery',\n  get: userID => async () => {\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response;\n  },\n});\n\nconst currentUserInfoQuery = selector({\n  key: 'CurrentUserInfoQuery',\n  get: ({get}) => get(userInfoQuery(get(currentUserIDState))),\n});\n\nconst friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    return friendList.map(friendID => get(userInfoQuery(friendID)));\n  },\n});\n\nfunction CurrentUserInfo() {\n  const currentUser = useRecoilValue(currentUserInfoQuery);\n  const friends = useRecoilValue(friendsInfoQuery);\n  const setCurrentUserID = useSetRecoilState(currentUserIDState);\n  return (\n    <div>\n      <h1>{currentUser.name}</h1>\n      <ul>\n        {friends.map(friend =>\n          <li key={friend.id} onClick={() => setCurrentUserID(friend.id)}>\n            {friend.name}\n          </li>\n        )}\n      </ul>\n    </div>\n  );\n}\n\nfunction MyApp() {\n  return (\n    <RecoilRoot>\n      <ErrorBoundary>\n        <React.Suspense fallback={<div>Loading...</div>}>\n          <CurrentUserInfo />\n        </React.Suspense>\n      </ErrorBoundary>\n    </RecoilRoot>\n  );\n}\n")),(0,s.kt)("h2",{id:"concurrent-requests"},"Concurrent Requests"),(0,s.kt)("p",null,"If you notice in the above example, the ",(0,s.kt)("inlineCode",{parentName:"p"},"friendsInfoQuery")," uses a query to get the info for each friend.  But, by doing this in a loop they are essentially serialized.  If the lookup is fast, maybe that's ok.  If it's expensive, you can use a concurrency helper such as ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/waitForAll"},(0,s.kt)("inlineCode",{parentName:"a"},"waitForAll"))," to run them in parallel.  This helper accepts both arrays and named objects of dependencies."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    const friends = get(waitForAll(\n      friendList.map(friendID => userInfoQuery(friendID))\n    ));\n    return friends;\n  },\n});\n")),(0,s.kt)("p",null,"You can use ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/waitForNone"},(0,s.kt)("inlineCode",{parentName:"a"},"waitForNone"))," to handle incremental updates to the UI with partial data"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const friendsInfoQuery = selector({\n  key: 'FriendsInfoQuery',\n  get: ({get}) => {\n    const {friendList} = get(currentUserInfoQuery);\n    const friendLoadables = get(waitForNone(\n      friendList.map(friendID => userInfoQuery(friendID))\n    ));\n    return friendLoadables\n      .filter(({state}) => state === 'hasValue')\n      .map(({contents}) => contents);\n  },\n});\n")),(0,s.kt)("h2",{id:"pre-fetching"},"Pre-Fetching"),(0,s.kt)("p",null,"For performance reasons you may wish to kick off fetching ",(0,s.kt)("em",{parentName:"p"},"before")," rendering.  That way the query can be going while we start rendering.  The ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early"},"React docs")," give some examples.  This pattern works with Recoil as well."),(0,s.kt)("p",null,"Let's change the above example to initiate a fetch for the next user info as soon as the user clicks the button to change users:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"function CurrentUserInfo() {\n  const currentUser = useRecoilValue(currentUserInfoQuery);\n  const friends = useRecoilValue(friendsInfoQuery);\n\n  const changeUser = useRecoilCallback(({snapshot, set}) => userID => {\n    snapshot.getLoadable(userInfoQuery(userID)); // pre-fetch user info\n    set(currentUserIDState, userID); // change current user to start new render\n  });\n\n  return (\n    <div>\n      <h1>{currentUser.name}</h1>\n      <ul>\n        {friends.map(friend =>\n          <li key={friend.id} onClick={() => changeUser(friend.id)}>\n            {friend.name}\n          </li>\n        )}\n      </ul>\n    </div>\n  );\n}\n")),(0,s.kt)("p",null,"Note that this pre-fetching works by triggering the ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/selectorFamily"},(0,s.kt)("inlineCode",{parentName:"a"},"selectorFamily()"))," to initiate an async query and populate the selector's cache.  If you are using an ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/utils/atomFamily"},(0,s.kt)("inlineCode",{parentName:"a"},"atomFamily()"))," instead, by either setting the atoms or relying on atom effects to initialize, then you should use ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilTransaction"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilTransaction_UNSTABLE()"))," instead of ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilCallback"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilCallback()")),", as trying to set the state of the provided ",(0,s.kt)("inlineCode",{parentName:"p"},"Snapshot")," will have no effect on the live state in the host ",(0,s.kt)("inlineCode",{parentName:"p"},"<RecoilRoot>"),"."),(0,s.kt)("h2",{id:"query-default-atom-values"},"Query Default Atom Values"),(0,s.kt)("p",null,"A common pattern is to use an atom to represent local editable state, but use a promise to query default values:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const currentUserIDState = atom({\n  key: 'CurrentUserID',\n  default: myFetchCurrentUserID(),\n});\n")),(0,s.kt)("p",null,"Or use a selector to defer the query or depend on other state.  Note that when using a selector the default atom value will remain dynamic, and update along with selector updates, until the atom is explicitly set by the user."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const UserInfoState = atom({\n  key: 'UserInfo',\n  default: selector({\n    key: 'UserInfo/Default',\n    get: ({get}) => myFetchUserInfo(get(currentUserIDState)),\n  }),\n});\n")),(0,s.kt)("p",null,"This can also be used with atom families:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userInfoState = atomFamily({\n  key: 'UserInfo',\n  default: id  => myFetchUserInfo(id),\n});\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userInfoState = atomFamily({\n  key: 'UserInfo',\n  default: selectorFamily({\n    key: 'UserInfo/Default',\n    get: id => ({get}) => myFetchUserInfo(id, get(paramsState)),\n  }),\n});\n")),(0,s.kt)("p",null,"If you would like bi-directional syncing of data, then consider ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"atom effects"),"."),(0,s.kt)("h2",{id:"async-queries-without-react-suspense"},"Async Queries Without React Suspense"),(0,s.kt)("p",null,"It is not necessary to use React Suspense for handling pending asynchronous selectors. You can also use the ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilValueLoadable"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilValueLoadable()"))," hook to determine the current status during rendering:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"function UserInfo({userID}) {\n  const userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));\n  switch (userNameLoadable.state) {\n    case 'hasValue':\n      return <div>{userNameLoadable.contents}</div>;\n    case 'loading':\n      return <div>Loading...</div>;\n    case 'hasError':\n      throw userNameLoadable.contents;\n  }\n}\n")),(0,s.kt)("h2",{id:"query-refresh"},"Query Refresh"),(0,s.kt)("p",null,"When using selectors to model data queries, selector evaluation should always provide a consistent value for a given state.  Selectors represent state derived from other atom and selector states.  Thus, selector evaluation functions should be idempotent for a given input, as it may be cached or executed multiple times.  However, if selectors obtain data from data queries it may be helpful for them to re-query in order to refresh with newer data or re-try after a failure.  There are a few ways to achieve this:"),(0,s.kt)("h3",{id:"userecoilrefresher"},(0,s.kt)("inlineCode",{parentName:"h3"},"useRecoilRefresher()")),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/useRecoilRefresher"},(0,s.kt)("inlineCode",{parentName:"a"},"useRecoilRefresher_UNSTABLE()"))," hook can be used to get a callback which you can call to clear any caches and force it to re-evaluate."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userInfoQuery = selectorFamily({\n  key: 'UserInfoQuery',\n  get: userID => async () => {\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response.data;\n  }\n})\n\nfunction CurrentUserInfo() {\n  const currentUserID = useRecoilValue(currentUserIDState);\n  const currentUserInfo = useRecoilValue(userInfoQuery(currentUserID));\n  const refreshUserInfo = useRecoilRefresher_UNSTABLE(userInfoQuery(currentUserID));\n\n  return (\n    <div>\n      <h1>{currentUserInfo.name}</h1>\n      <button onClick={() => refreshUserInfo()}>Refresh</button>\n    </div>\n  );\n}\n")),(0,s.kt)("h3",{id:"use-a-request-id"},"Use a Request ID"),(0,s.kt)("p",null,"Selector evaluation should provide a consistent value for a given state based on its input (dependent state or family parameters).  So, you could add a request ID as either a family parameter or a dependency to your query.  For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userInfoQueryRequestIDState = atomFamily({\n  key: 'UserInfoQueryRequestID',\n  default: 0,\n});\n\nconst userInfoQuery = selectorFamily({\n  key: 'UserInfoQuery',\n  get: userID => async ({get}) => {\n    get(userInfoQueryRequestIDState(userID)); // Add request ID as a dependency\n    const response = await myDBQuery({userID});\n    if (response.error) {\n      throw response.error;\n    }\n    return response.data;\n  },\n});\n\nfunction useRefreshUserInfo(userID) {\n  const setUserInfoQueryRequestID = useSetRecoilState(userInfoQueryRequestIDState(userID));\n  return () => {\n    setUserInfoQueryRequestID(requestID => requestID + 1);\n  };\n}\n\nfunction CurrentUserInfo() {\n  const currentUserID = useRecoilValue(currentUserIDState);\n  const currentUserInfo = useRecoilValue(userInfoQuery(currentUserID));\n  const refreshUserInfo = useRefreshUserInfo(currentUserID);\n\n  return (\n    <div>\n      <h1>{currentUserInfo.name}</h1>\n      <button onClick={refreshUserInfo}>Refresh</button>\n    </div>\n  );\n}\n")),(0,s.kt)("h3",{id:"use-an-atom"},"Use an Atom"),(0,s.kt)("p",null,"Another option is to use an atom, instead of a selector, to model the query results.  You can imperatively update the atom state with the new query results based on your refresh policy."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const userInfoState = atomFamily({\n  key: 'UserInfo',\n  default: userID => fetch(userInfoURL(userID)),\n});\n\n// React component to refresh query\nfunction RefreshUserInfo({userID}) {\n  const refreshUserInfo = useRecoilCallback(({set}) => async id => {\n    const userInfo = await myDBQuery({userID});\n    set(userInfoState(userID), userInfo);\n  }, [userID]);\n\n  // Refresh user info every second\n  useEffect(() => {\n    const intervalID = setInterval(refreshUserInfo, 1000);\n    return () => clearInterval(intervalID);\n  }, [refreshUserInfo]);\n\n  return null;\n}\n")),(0,s.kt)("p",null,"Note that atoms do not ",(0,s.kt)("em",{parentName:"p"},"currently")," support accepting a ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise")," as the new value.  So, you cannot currently put the atom in a pending state for React Suspense while the query refresh is pending, if that is your desired behavior.  However, you could store an object which manually encodes the current loading status as well as the actual results to explicitly handle this."),(0,s.kt)("p",null,"Also consider ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/atom-effects"},"atom effects")," for query synchronization of atoms."),(0,s.kt)("h3",{id:"retry-query-from-error-message"},"Retry query from error message"),(0,s.kt)("p",null,"Here's a fun little example to find and retry queries based on errors thrown and caught in an ",(0,s.kt)("inlineCode",{parentName:"p"},"<ErrorBoundary>")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"function QueryErrorMessage({error}) {\n  const snapshot = useRecoilSnapshot();\n  const selectors = useMemo(() => {\n    const ret = [];\n    for (const node of snapshot.getNodes_UNSTABLE({isInitialized: true})) {\n      const {loadable, type} = snapshot.getInfo_UNSTABLE(node);\n      if (loadable != null && loadable.state === 'hasError' && loadable.contents === error) {\n        ret.push(node);\n      }\n    }\n    return ret;\n  }, [snapshot, error]);\n  const retry = useRecoilCallback(({refresh}) =>\n    () => selectors.forEach(refresh),\n    [selectors],\n  );\n\n  return selectors.length > 0 && (\n    <div>\n      Error: {error.toString()}\n      Query: {selectors[0].key}\n      <button onClick={retry}>Retry</button>\n    </div>\n  );\n}\n")))}p.isMDXComponent=!0}}]);