diff --git a/Makefile b/Makefile
index 3e17365b8..5b3e54e7f 100644
--- a/Makefile
+++ b/Makefile
@@ -9,7 +9,7 @@ PREFIX ?= /usr/local
 BINDIR ?= $(PREFIX)/bin
 MANDIR ?= $(PREFIX)/man
 SHAREDIR ?= $(PREFIX)/share
-PYTHON ?= /usr/bin/env python
+PYTHON ?= /usr/bin/env python3
 
 # set SYSCONFDIR to /etc if PREFIX=/usr or PREFIX=/usr/local
 SYSCONFDIR = $(shell if [ $(PREFIX) = /usr -o $(PREFIX) = /usr/local ]; then echo /etc; else echo $(PREFIX)/etc; fi)
diff --git a/youtube_dl/YoutubeDL.py b/youtube_dl/YoutubeDL.py
index 6a44bc7ba..b37d01316 100755
--- a/youtube_dl/YoutubeDL.py
+++ b/youtube_dl/YoutubeDL.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # coding: utf-8
 
 from __future__ import absolute_import, unicode_literals
@@ -561,7 +561,8 @@ class YoutubeDL(object):
     def __exit__(self, *args):
         self.restore_console_title()
 
-        if self.params.get('cookiefile') is not None:
+        opts_cookiefile = self.params.get('cookiefile')
+        if opts_cookiefile is not None and os.path.exists(opts_cookiefile):
             self.cookiejar.save(ignore_discard=True, ignore_expires=True)
 
     def trouble(self, message=None, tb=None):
@@ -847,7 +848,7 @@ class YoutubeDL(object):
         """
         result_type = ie_result.get('_type', 'video')
 
-        if result_type in ('url', 'url_transparent'):
+        if result_type in ('url', 'url_transparent', 'url_transparent_id'):
             ie_result['url'] = sanitize_url(ie_result['url'])
             extract_flat = self.params.get('extract_flat', False)
             if ((extract_flat == 'in_playlist' and 'playlist' in extra_info)
@@ -866,7 +867,7 @@ class YoutubeDL(object):
                                      download,
                                      ie_key=ie_result.get('ie_key'),
                                      extra_info=extra_info)
-        elif result_type == 'url_transparent':
+        elif result_type in ('url_transparent', 'url_transparent_id'):
             # Use the information from the embedding page
             info = self.extract_info(
                 ie_result['url'], ie_key=ie_result.get('ie_key'),
@@ -880,7 +881,11 @@ class YoutubeDL(object):
 
             force_properties = dict(
                 (k, v) for k, v in ie_result.items() if v is not None)
-            for f in ('_type', 'url', 'id', 'extractor', 'extractor_key', 'ie_key'):
+            if result_type == 'url_transparent':
+                rmprops = ('_type', 'url', 'id', 'extractor', 'extractor_key', 'ie_key')
+            else:
+                rmprops = ('_type', 'url', 'extractor', 'extractor_key', 'ie_key')
+            for f in rmprops:
                 if f in force_properties:
                     del force_properties[f]
             new_result = info.copy()
@@ -1873,8 +1878,7 @@ class YoutubeDL(object):
                         video_ext, audio_ext = video.get('ext'), audio.get('ext')
                         if video_ext and audio_ext:
                             COMPATIBLE_EXTS = (
-                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v', 'ismv', 'isma'),
-                                ('webm')
+                                ('mp3', 'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v', 'ismv', 'isma')
                             )
                             for exts in COMPATIBLE_EXTS:
                                 if video_ext in exts and audio_ext in exts:
@@ -2316,8 +2320,11 @@ class YoutubeDL(object):
         else:
             opts_cookiefile = expand_path(opts_cookiefile)
             self.cookiejar = YoutubeDLCookieJar(opts_cookiefile)
-            if os.access(opts_cookiefile, os.R_OK):
-                self.cookiejar.load(ignore_discard=True, ignore_expires=True)
+            if os.access(opts_cookiefile, os.R_OK) or os.path.exists(opts_cookiefile):
+                try:
+                    self.cookiejar.load(ignore_discard=True, ignore_expires=True)
+                except:
+                    pass
 
         cookie_processor = YoutubeDLCookieProcessor(self.cookiejar)
         if opts_proxy is not None:
diff --git a/youtube_dl/__init__.py b/youtube_dl/__init__.py
index 9a659fc65..6bc41020c 100644
--- a/youtube_dl/__init__.py
+++ b/youtube_dl/__init__.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # coding: utf-8
 
 from __future__ import unicode_literals
diff --git a/youtube_dl/__main__.py b/youtube_dl/__main__.py
index 138f5fbec..6b473177e 100755
--- a/youtube_dl/__main__.py
+++ b/youtube_dl/__main__.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 from __future__ import unicode_literals
 
 # Execute with
diff --git a/youtube_dl/extractor/common.py b/youtube_dl/extractor/common.py
index 859786617..48180452a 100644
--- a/youtube_dl/extractor/common.py
+++ b/youtube_dl/extractor/common.py
@@ -963,6 +963,9 @@ class InfoExtractor(object):
     @staticmethod
     def playlist_result(entries, playlist_id=None, playlist_title=None, playlist_description=None):
         """Returns a playlist"""
+        if isinstance(entries, list) and len(entries) == 1:
+            return entries[0]
+
         video_info = {'_type': 'playlist',
                       'entries': entries}
         if playlist_id:
diff --git a/youtube_dl/extractor/extractors.py b/youtube_dl/extractor/extractors.py
index 4adcae1e5..6b939dcc1 100644
--- a/youtube_dl/extractor/extractors.py
+++ b/youtube_dl/extractor/extractors.py
@@ -1165,6 +1165,13 @@ from .tnaflix import (
     MovieFapIE,
 )
 from .toggle import ToggleIE
+from .tokyomotion2 import (
+    TokyoMotion2IE,
+    TokyoMotionUser2IE,
+    TokyoMotionUserFavs2IE,
+    TokyoMotionSearches2IE,
+    TokyoMotionScanner2IE,
+)
 from .tonline import TOnlineIE
 from .toongoggles import ToonGogglesIE
 from .toutv import TouTvIE
diff --git a/youtube_dl/extractor/tokyomotion2.py b/youtube_dl/extractor/tokyomotion2.py
new file mode 100644
index 000000000..85fe70e59
--- /dev/null
+++ b/youtube_dl/extractor/tokyomotion2.py
@@ -0,0 +1,129 @@
+# coding: utf-8
+from __future__ import unicode_literals
+
+import re
+
+from .common import InfoExtractor
+from ..utils import (
+    sanitized_Request,
+    ExtractorError,
+)
+from ..compat import (
+    compat_str,
+)
+
+try:
+    from urllib import quote
+except ImportError:
+    from urllib.parse import quote
+
+class TokyoMotion2BaseIE(InfoExtractor):
+    IE_DESC = False  # Do not list
+    def download_page(self, url, video_id):
+        # This fails
+        # return self._download_webpage(url, video_id)
+        # Use ones in generic extractor
+        request = sanitized_Request(url)
+        request.add_header('Accept-Encoding', '*')
+        full_response = self._request_webpage(request, video_id)
+        return self._webpage_read_content(full_response, url, video_id)
+
+    def _int_id(self, url):
+        if '_VALID_URL_RE' not in TokyoMotion2IE.__dict__:
+            TokyoMotion2IE._VALID_URL_RE = re.compile(TokyoMotion2IE._VALID_URL)
+        m = TokyoMotion2IE._VALID_URL_RE.match(url)
+        return int(compat_str(m.group('id')))
+
+    def _extract_video_urls(self, variant, webpage):
+        return ('https://www.%smotion.net%s' % (variant, quote(frg.group()))
+            for frg in re.finditer(r'/video/(?P<id>\d+)/[^#?&"\']+', webpage))
+
+    def _do_paging(self, template, variant, user_id):
+        index = 1
+        all_matches = []
+        while True:
+            newurl = self.USER_VIDEOS_FULL_URL % (variant, user_id, index)
+            self.to_screen('Downloading page %d' % index)
+            webpage = self.download_page(newurl, user_id)
+            all_matches.extend(self._extract_video_urls(variant, webpage))
+            index = index + 1
+            if ('videos?page=%d"' % index) not in webpage and ('&page=%d"' % index) not in webpage:
+                break
+        return (self.url_result(url) for url in sorted(set(all_matches), key=self._int_id))
+
+class TokyoMotionPlaylistBase2IE(TokyoMotion2BaseIE):
+    IE_DESC = False  # Do not list
+    def _real_extract(self, url):
+        user_id = self._match_id(url)
+        variant = self._VALID_URL_RE.match(url).group('variant')
+        matches = self._do_paging(self.USER_VIDEOS_FULL_URL, variant, user_id)
+        return self.playlist_result(matches, user_id, self.TITLE % user_id)
+
+class TokyoMotion2IE(TokyoMotion2BaseIE):
+    IE_NAME = 'tokyomotion'
+    _VALID_URL = r'(?P<url>https?://(?:www\.)?(?P<variant>tokyo|osaka)motion\.net/video/(?P<id>\d+)/[^#?&]+)(?:#.*)?'
+    _TEST = {
+        'url': 'https://www.tokyomotion.net/video/915034/%E9%80%86%E3%81%95',
+        'info_dict': {
+            'id': '915034',
+            'ext': 'mp4',
+            'title': '逆さ',
+        }
+    }
+
+    def _real_extract(self, url):
+        video_id = self._match_id(url)
+        url = self._VALID_URL_RE.match(url).group('url')
+        variant = self._VALID_URL_RE.match(url).group('variant')
+        webpage = self.download_page(url, video_id)
+
+        title = self._og_search_title(webpage, default=None)
+
+        entries = self._parse_html5_media_entries(url, webpage, video_id, m3u8_id='hls')
+        variant_name = 'TokyoMotion' if variant == 'tokyo' else 'OsakaMotion'
+        if entries:
+            entry = entries[0]
+            self._sort_formats(entry['formats'])
+        else:
+            raise ExtractorError('Private video', expected=True)
+        entry.update({
+            'id': video_id,
+            'title': title,
+            'age_limit': 18,
+            'series': variant_name,
+        })
+        return entry
+
+class TokyoMotionUser2IE(TokyoMotionPlaylistBase2IE):
+    IE_NAME = 'tokyomotion:user'
+    _VALID_URL = r'https?://(?:www\.)?(?P<variant>tokyo|osaka)motion\.net/user/(?P<id>[^/]+)(?:/videos)?'
+    _TEST = {}
+    USER_VIDEOS_FULL_URL = 'https://www.%smotion.net/user/%s/videos?page=%d'
+    TITLE = 'Uploads from %s'
+
+class TokyoMotionUserFavs2IE(TokyoMotionPlaylistBase2IE):
+    IE_NAME = 'tokyomotion:user:favs'
+    _VALID_URL = r'https?://(?:www\.)?(?P<variant>tokyo|osaka)motion\.net/user/(?P<id>[^/]+)/favorite/videos'
+    _TEST = {}
+    USER_VIDEOS_FULL_URL = 'https://www.%smotion.net/user/%s/favorite/videos?page=%d'
+    TITLE = 'Favorites from %s'
+
+class TokyoMotionSearches2IE(TokyoMotionPlaylistBase2IE):
+    IE_NAME = 'tokyomotion:searches'
+    _VALID_URL = r'https?://(?:www\.)?(?P<variant>tokyo|osaka)motion\.net/search\?search_query=(?P<id>[^/&]+)(?:&search_type=videos)?(?:&page=\d+)?'
+    _TEST = {}
+    USER_VIDEOS_FULL_URL = 'https://www.%smotion.net/search?search_query=%s&search_type=videos&page=%d'
+    TITLE = 'Search results for %s'
+
+class TokyoMotionScanner2IE(TokyoMotion2BaseIE):
+    IE_DESC = False  # Do not list
+    IE_NAME = 'tokyomotion:scanner'
+    _VALID_URL = r'tmscan:https?://(?:www\.)?(?P<variant>tokyo|osaka)motion\.net/(?P<id>.*)'
+    _TEST = {}
+    def _real_extract(self, url):
+        user_id = self._match_id(url) or ''
+        variant = self._VALID_URL_RE.match(url).group('variant')
+        webpage = self.download_page(url[7:], user_id)
+        matches = self._extract_video_urls(variant, webpage)
+        playlist = (self.url_result(url) for url in sorted(set(matches), key=self._int_id))
+        return self.playlist_result(playlist, user_id, 'Scanned results for %s' % url)
diff --git a/youtube_dl/extractor/twitter.py b/youtube_dl/extractor/twitter.py
index cebb6238c..0ee97f434 100644
--- a/youtube_dl/extractor/twitter.py
+++ b/youtube_dl/extractor/twitter.py
@@ -175,11 +175,17 @@ class TwitterCardIE(TwitterBaseIE):
                 u, video_id, headers={'Referer': 'https://twitter.com/'})
 
             iframe_url = self._html_search_regex(
-                r'<iframe[^>]+src="((?:https?:)?//(?:www\.youtube\.com/embed/[^"]+|(?:www\.)?vine\.co/v/\w+/card))"',
+                r'<iframe[^>]+src="((?:https?:)?//(?:www\.)?vine\.co/v/\w+/card)"',
                 webpage, 'video iframe', default=None)
             if iframe_url:
                 return self.url_result(iframe_url)
 
+            iframe_url = self._html_search_regex(
+                r'<iframe[^>]+src="((?:https?:)?//www\.youtube\.com/embed/[^"]+)"',
+                webpage, 'video iframe', default=None)
+            if iframe_url:
+                raise ExtractorError('Embedded YouTube video is not accepted', expected=True)
+
             config = self._parse_json(self._html_search_regex(
                 r'data-(?:player-)?config="([^"]+)"', webpage,
                 'data player config', default='{}'),
diff --git a/youtube_dl/postprocessor/ffmpeg.py b/youtube_dl/postprocessor/ffmpeg.py
index 70416c25e..d5f0d5e8d 100644
--- a/youtube_dl/postprocessor/ffmpeg.py
+++ b/youtube_dl/postprocessor/ffmpeg.py
@@ -362,6 +362,8 @@ class FFmpegVideoConvertorPP(FFmpegPostProcessor):
         options = []
         if self._preferedformat == 'avi':
             options.extend(['-c:v', 'libxvid', '-vtag', 'XVID'])
+        if self._preferedformat == 'mkv':
+            options.extend(['-c:v', 'copy', '-c:a', 'copy'])
         prefix, sep, ext = path.rpartition('.')
         outpath = prefix + sep + self._preferedformat
         self._downloader.to_screen('[' + 'ffmpeg' + '] Converting video from %s to %s, Destination: ' % (information['ext'], self._preferedformat) + outpath)
diff --git a/youtube_dl/update.py b/youtube_dl/update.py
index 002ea7f33..702b6d7d6 100644
--- a/youtube_dl/update.py
+++ b/youtube_dl/update.py
@@ -7,6 +7,7 @@ import hashlib
 import os
 import subprocess
 import sys
+import time
 from zipimport import zipimporter
 
 from .utils import encode_compat_str
@@ -31,10 +32,9 @@ def rsa_verify(message, signature, key):
 def update_self(to_screen, verbose, opener):
     """Update the program file with the latest version from the repository"""
 
-    UPDATE_URL = 'https://yt-dl.org/update/'
+    UPDATE_URL = 'https://nao20010128nao.github.io/ytdl-patched/'
     VERSION_URL = UPDATE_URL + 'LATEST_VERSION'
     JSON_URL = UPDATE_URL + 'versions.json'
-    UPDATES_RSA_KEY = (0x9d60ee4d8f805312fdb15a62f87b95bd66177b91df176765d13514a0f1754bcd2057295c5b6f1d35daa6742c3ffc9a82d3e118861c207995a8031e151d863c9927e304576bc80692bc8e094896fcf11b66f3e29e04e3a71e9a11558558acea1840aec37fc396fb6b65dc81a1c4144e03bd1c011de62e3f1357b327d08426fe93, 65537)
 
     if not isinstance(globals().get('__loader__'), zipimporter) and not hasattr(sys, 'frozen'):
         to_screen('It looks like you installed youtube-dl with a package manager, pip, setup.py or a tarball. Please use that to update.')
@@ -61,19 +61,14 @@ def update_self(to_screen, verbose, opener):
             to_screen(encode_compat_str(traceback.format_exc()))
         to_screen('ERROR: can\'t obtain versions info. Please try again later.')
         return
-    if 'signature' not in versions_info:
-        to_screen('ERROR: the versions file is not signed or corrupted. Aborting.')
-        return
-    signature = versions_info['signature']
-    del versions_info['signature']
-    if not rsa_verify(json.dumps(versions_info, sort_keys=True).encode('utf-8'), signature, UPDATES_RSA_KEY):
-        to_screen('ERROR: the versions file signature is invalid. Aborting.')
-        return
+
+    # Don't test signatures for now
 
     version_id = versions_info['latest']
 
     def version_tuple(version_str):
-        return tuple(map(int, version_str.split('.')))
+        # This assumes timestamp is in UTC
+        return time.strptime(version_str, '%a %b %d %H:%M:%S UTC %Y')
     if version_tuple(__version__) >= version_tuple(version_id):
         to_screen('youtube-dl is up to date (%s)' % __version__)
         return
diff --git a/youtube_dl/utils.py b/youtube_dl/utils.py
index 798757241..0dad530b2 100644
--- a/youtube_dl/utils.py
+++ b/youtube_dl/utils.py
@@ -83,7 +83,13 @@ compiled_regex_type = type(re.compile(''))
 
 
 def random_user_agent():
-    _USER_AGENT_TPL = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/%s Safari/537.36'
+    _USER_AGENT_TPL = 'Mozilla/5.0 (Windows NT %s; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/%s Safari/537.36'
+    _WINDOWS_VERSIONS = (
+        '6.1', # 7
+        '6.2', # 8
+        '6.3', # 8.1
+        '10.0',
+    )
     _CHROME_VERSIONS = (
         '74.0.3729.129',
         '76.0.3780.3',
@@ -1662,7 +1668,7 @@ def random_user_agent():
         '70.0.3513.0',
         '69.0.3497.28',
     )
-    return _USER_AGENT_TPL % random.choice(_CHROME_VERSIONS)
+    return _USER_AGENT_TPL % (random.choice(_WINDOWS_VERSIONS), random.choice(_CHROME_VERSIONS))
 
 
 std_headers = {
